// File: ./include/common/ISerializable.hpp
#pragma once
#include <json.hpp>
#include <string>

class ISerializable
{
public:
    virtual ~ISerializable() = default;
    virtual nlohmann::json serialize() const = 0;
    virtual void deserialize(const nlohmann::json &data) = 0;
};


// File: ./include/common/CellColorType.hpp
#pragma once
#include <cstdint>

enum class CellColorType : uint8_t
{
    Empty = 0,
    Red,
    Green,
    Blue,
    Yellow,
};



// File: ./include/common/PlayerData.hpp
#pragma once
#include <string>
#include "ISerializable.hpp"
#include "json.hpp"

struct PlayerData : public ISerializable
{
    int playerID = -1;
    std::string playerName;
    int score = 0;
    bool isConnected = false;

    nlohmann::json serialize() const override
    {
        return {
            {"playerID", playerID},
            {"playerName", playerName},
            {"score", score},
            {"isConnected", isConnected}};
    }

    void deserialize(const nlohmann::json &data) override
    {
        playerID = data.at("playerID").get<int>();
        playerName = data.at("playerName").get<std::string>();
        score = data.at("score").get<int>();
        isConnected = data.at("isConnected").get<bool>();
    }
};



// File: ./include/common/PacketType.hpp
#pragma once

enum class PacketType : char
{
    // Game actions/commands Packets
    JOIN_REQUEST,
    JOIN_ACCEPTED,
    JOIN_DENIED,
    REQUEST_START,
    STARTING_GAME,
    RESTART,
    PAUSE,
    RESUME,
    LEFT,
    RIGHT,
    ROTATE_LEFT,
    ROTATE_RIGHT,
    DROP_FASTER,
    DROP_INSTANT,

    // Network/connection-related
    HEARTBEAT,  // A heartbeat packet to keep the connection alive
    CONNECT,    // A packet sent upon connecting
    DISCONNECT, // A packet sent upon disconnection

    GAME_SCREEN,
    PLAYER_LIST,

    // Error packet threating
    PARSING_ERROR // Reserved for any custom packet types
};

// Utility function to convert PacketType to a string (for debugging)
inline const char *PacketTypeToString(PacketType type)
{
    switch (type)
    {
    case PacketType::JOIN_REQUEST:
        return "JOIN_REQUEST";
    case PacketType::JOIN_ACCEPTED:
        return "JOIN_ACCEPTED";
    case PacketType::JOIN_DENIED:
        return "JOIN_DENIED";
    case PacketType::REQUEST_START:
        return "START";
    case PacketType::RESTART:
        return "RESTART";
    case PacketType::PAUSE:
        return "PAUSE";
    case PacketType::RESUME:
        return "RESUME";
    case PacketType::LEFT:
        return "LEFT";
    case PacketType::RIGHT:
        return "RIGHT";
    case PacketType::ROTATE_LEFT:
        return "ROTATE_LEFT";
    case PacketType::ROTATE_RIGHT:
        return "ROTATE_RIGHT";
    case PacketType::DROP_FASTER:
        return "DROP_FASTER";
    case PacketType::DROP_INSTANT:
        return "DROP_INSTANT";
    case PacketType::HEARTBEAT:
        return "HEARTBEAT";
    case PacketType::CONNECT:
        return "CONNECT";
    case PacketType::DISCONNECT:
        return "DISCONNECT";
    case PacketType::PARSING_ERROR:
        return "PARSING_ERROR";
    default:
        return "UNKNOWN_PACKET_TYPE";
    }
}


// File: ./include/common/TetrisAction.hpp
#pragma once
#include "PacketType.hpp"

enum class TetrisAction
{
    EMPTY = 0,
    LEFT,
    RIGHT,
    ROTATE_LEFT,
    ROTATE_RIGHT,
    DROP_FASTER,
    DROP_INSTANT
};

inline const TetrisAction getActionFromPacketType(PacketType type)
{
    TetrisAction action = TetrisAction::EMPTY;
    switch (type)
    {
    case PacketType::LEFT:
        action = TetrisAction::LEFT;
        break;
    case PacketType::RIGHT:
        action = TetrisAction::RIGHT;
        break;
    case PacketType::ROTATE_LEFT:
        action = TetrisAction::ROTATE_LEFT;
        break;
    case PacketType::ROTATE_RIGHT:
        action = TetrisAction::ROTATE_RIGHT;
        break;
    case PacketType::DROP_FASTER:
        action = TetrisAction::DROP_FASTER;
        break;
    case PacketType::DROP_INSTANT:
        action = TetrisAction::DROP_INSTANT;
        break;
    default:
        break;
    }

    return action;
}
inline const char *TetrisActionToString(TetrisAction action)
{
    switch (action)
    {
    case TetrisAction::EMPTY:
        return "EMPTY";
    case TetrisAction::LEFT:
        return "LEFT";
    case TetrisAction::RIGHT:
        return "RIGHT";
    case TetrisAction::ROTATE_LEFT:
        return "ROTATE_LEFT";
    case TetrisAction::ROTATE_RIGHT:
        return "ROTATE_RIGHT";
    case TetrisAction::DROP_FASTER:
        return "DROP_FASTER";
    case TetrisAction::DROP_INSTANT:
        return "DROP_INSTANT";
    default:
        return "UNKNOWN_ACTION";
    }
}


// File: ./include/common/NetworkManager.hpp
#pragma once

#include "PacketType.hpp"
#include <json.hpp>

#include <enet/enet.h>
#include <queue>
#include <vector>
#include <atomic>
#include <unordered_map>
#include <functional>
#include <thread>
#include <memory>

// This struct represents a network packet. It contains information such as the packet type,
// data payload, and the peer to which the packet is being sent or received from.
struct Packet
{
    PacketType type;           // The type of the packet (ACTION, HEARTBEAT, etc.)
    std::vector<uint8_t> data; // Data payload of the packet
    ENetPeer *peer;            // The peer that the packet is being sent to or received from

    // Constructor to initialize a packet with its type, data, and optional destination peer.
    Packet(PacketType t, const std::vector<uint8_t> &d, ENetPeer *dest = nullptr)
        : type(t), data(d), peer(dest) {}

    // New constructor that accepts a JSON object
    Packet(PacketType t, const nlohmann::json &j, ENetPeer *dest = nullptr)
        : type(t), peer(dest)
    {
        // Convert JSON to string
        std::string jsonStr = j.dump();
        // Store as bytes
        data.assign(jsonStr.begin(), jsonStr.end());
    }

    // Serialize the packet to raw byte data so it can be sent over the network.
    std::vector<uint8_t> toRawData() const
    {
        std::vector<uint8_t> rawData;
        rawData.push_back(static_cast<uint8_t>(type));           // First byte stores the packet type
        rawData.insert(rawData.end(), data.begin(), data.end()); // Append the rest of the data
        return rawData;
    }

    // Helper method to parse the data vector into a JSON object
    nlohmann::json toJson() const
    {
        std::string jsonStr(data.begin(), data.end());
        return nlohmann::json::parse(jsonStr);
    }
};

// The NetworkManager class is responsible for managing all network communication.
// It sets up the network host, handles incoming and outgoing packets, and provides
// methods to register listeners for specific packet types.
class NetworkManager
{
public:
    NetworkManager();          // Constructor: Initializes the ENet library and network manager.
    virtual ~NetworkManager(); // Destructor: Cleans up network resources and stops the network loop.

    static const int version = 1; // NetworkManager version for debugging purposes

    // Registers a listener function for a specific packet type.
    // The listener will be called whenever a packet of the given type is received.
    void registerListener(PacketType packetType, std::function<void(const Packet &)> callback);

    // Adds a packet to the outgoing packet queue to be sent to its destination peer.
    void send_packet(const Packet &packet);

    // Checks whether the network task (event loop) is currently running.
    bool isRunning() const;

    // Utility function to convert a 32-bit integer IP address to an IPv4 string (e.g., "192.168.1.1").
    static char *uint32_to_ipv4(uint32_t ip_addr);

    // Prints a message with a timestamp to the console for debugging purposes.
    static void network_print(const char *array);

    // Returns the ENetHost object, which represents either the client or server in ENet.
    ENetHost *getHost();
    
    std::vector<ENetPeer *> getPeers();

protected:
    ENetHost *host = nullptr; // ENet host, which can either be a server or a client.

    // Converts an ENet packet into a custom Packet structure by extracting the packet type and data.
    static Packet parsePacket(const ENetPacket *enetPacket, ENetPeer *sourcePeer);

    // Handles a received packet by calling the registered listener for its packet type.
    void handlePacket(Packet &packet, ENetPeer *peer);

    // Abstract method to handle when a peer connects to the host. Implemented by subclasses.
    virtual void onPeerConnect(ENetPeer *peer) = 0;

    // Abstract method to handle when a peer disconnects from the host. Implemented by subclasses.
    virtual void onPeerDisconnect(ENetPeer *peer) = 0;

    // Starts the network event loop in a separate thread to process incoming and outgoing packets.
    void TaskStartNetwork();

    // Stops the network loop and cleans up resources related to networking.
    void TaskStopNetwork();

private:
    std::thread networkThread;         // Thread for running the network event loop.
    std::atomic<bool> running = false; // Atomic flag to indicate whether the network loop is active.

    // Queue for outgoing packets that need to be sent to peers.
    std::queue<Packet> outgoingPackets;

    // Queue for incoming packets that have been received but not yet processed.
    std::queue<Packet> incommingPackets;

    // A map that associates packet types (as uint8_t) with their corresponding listener functions.
    std::unordered_map<uint8_t, std::function<void(const Packet &)>> listeners;

    // Processes events received from ENet, such as peer connections, disconnections, and packet receptions.
    void processENetEvent(ENetEvent &event);

    // Processes any incoming packets in the queue and triggers the appropriate listeners.
    void processIncomingPackets();

    // Sends any outgoing packets in the queue to their destination peers or broadcasts them to all peers.
    void sendOutgoingPackets();

    // Creates an ENet packet from a custom Packet structure, ready to be sent over the network.
    ENetPacket *createENetPacket(const Packet &packet);

    // The main network loop that continuously processes ENet events, sends outgoing packets, and handles incoming ones.
    void TaskNetwork();
};



// File: ./include/common/ThreadSafeQueue.hpp
#pragma once

#include <queue>
#include <mutex>
#include <condition_variable>

template <typename T>
class ThreadSafeQueue
{
private:
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable cond_;

public:
    void push(T value)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(std::move(value));
        cond_.notify_one();
    }

    bool pop(T &value)
    {
        std::unique_lock<std::mutex> lock(mutex_);
        if (queue_.empty())
            return false;
        value = std::move(queue_.front());
        queue_.pop();
        return true;
    }

    void wait_and_pop(T &value)
    {
        std::unique_lock<std::mutex> lock(mutex_);
        cond_.wait(lock, [&]
                   { return !queue_.empty(); });
        value = std::move(queue_.front());
        queue_.pop();
    }

    bool empty() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.empty();
    }
};


// File: ./include/server/game/baseTetromino.hpp
#pragma once

#include <string>
#include <vector>
#include "CellColorType.hpp"
#include "TetrisAction.hpp"

class Tetromino
{
protected:
    std::vector<std::vector<int>> shape;
    int x, y;
    CellColorType color;
    

public:
    static const std::vector<CellColorType> tetromino_colors;
    static const std::vector<char> types;
    bool gravity = false;
    
    Tetromino(int x0, int y0, CellColorType color) : x(x0), y(y0), color(color) {}
    virtual ~Tetromino() = default;

    int getX() const;
    int getY() const;

    CellColorType getColor() const;

    bool getGravity() const;

    const std::vector<std::vector<int>> &getShape() const;

    void evolveStates(bool forward, TetrisAction lastMove);

    void dropGravity();
};


// File: ./include/server/game/board.hpp
#pragma once

#include <memory>
#include "Tetromino.hpp"
#include <iostream>
#include "game/Cell.hpp"
#include "json.hpp"

class ServerManager;

class TetrisBoard
{
private:
    std::vector<std::vector<std::shared_ptr<Cell>>> grid;
    std::vector<std::vector<std::shared_ptr<Cell>>> lastBroadcastedGrid;

    ServerManager &serverManager;

public:
    static const int WIDTH;
    static const int HEIGHT;

    TetrisBoard(ServerManager &serverManager);

    bool reachedTop();
    void printStatus();
    void clear();

    // Melhor seria se fosse const, mas é a vida, não consigo pensar em outro jeito de
    // checar a colisao sem mudar o objeto e ver se dá merda, na prática faz-se a ação inversa depois, então safe
    bool checkCollision(Tetromino &currentTetromino, TetrisAction action);
    int clearLines();
    bool placeTetromino(const Tetromino &currentTetromino, bool fallen);
    static int normalizedY(int y);

    void clearFallingTetrominos();
    void clearFalledTetrominos();

    std::vector<std::vector<std::shared_ptr<Cell>>> &getGrid();

    void sendBoardState(const nlohmann::json &boardJson) const;

    bool gridsAreEqual(const std::vector<std::vector<std::shared_ptr<Cell>>> &grid1,
                       const std::vector<std::vector<std::shared_ptr<Cell>>> &grid2) const;

    void broadcastBoardState();
    void updateLastBroadcastedGrid();
    nlohmann::json constructBoardJson() const;
};


// File: ./include/server/game/gameManager.hpp
#pragma once

#include <iostream>
#include <chrono>
#include <thread>
#include <memory>
#include <atomic>

#include "ThreadSafeQueue.hpp"
#include "game/tetrominoFactory.hpp"
#include "TetrisAction.hpp"
#include "ServerManager.hpp"
#include "board.hpp"
#include <mutex>

class GameManager
{
private:
    std::mutex gameStateMutex;
    ThreadSafeQueue<TetrisAction> actionQueue;

    TetrisBoard board;
    std::unique_ptr<Tetromino> currentTetromino;

    std::atomic<bool> isRunning;
    int score;
    int level;
    int nLinesClearedThisLevel;

    const int minTimeMs = 400;
    int gravityTimeMs;        // Current gravity time in ms
    int levelUpGravityTimeMs; // How much to reduce gravity time on level up

    std::chrono::steady_clock::time_point lastGravityTick; // To track gravity intervals

    std::thread gameThread;         // The thread running the game loop
    std::atomic<bool> threadActive; // To track if the thread is active

    TetrisAction lastM = TetrisAction::EMPTY;

    void handleInput(TetrisAction action);
    void runGameLoop();

public:
    GameManager(ServerManager &serverManager);

    int lines2Points(int nLines);

    // Starts the game loop in a separate thread
    void startGameLoop();

    // Stops the game loop and waits for the thread to finish
    void stopGameLoop();

    // Checks if the game is currently running
    bool isGameRunning() const;

    // Checks if the game thread is running
    bool isThreadRunning() const;

    void spawnTetromino();
    void update();

    void enqueueAction(TetrisAction action)
    {
        actionQueue.push(action);
    }
};



// File: ./include/server/game/nonSymmetricTetromino.hpp
#pragma once

// Needed for std::reverse
#include "algorithm"
#include "Tetromino.hpp"

class NonSymmetricTetromino : public Tetromino
{

protected:
    // Only called locally, in the constructor
    void invertShape()
    {
        // Logic to invert the shape based on the tetromino type
        for (auto &y : shape)
        {
            std::reverse(y.begin(), y.end());
        }
    }

public:
    // Basically just calls the default constructor & inverts the shape
    NonSymmetricTetromino(int x0, int y0, CellColorType color, bool invert = false)
        : Tetromino(x0, y0, color)
    {
    }
};


// File: ./include/server/game/tetrominoFactory.hpp
#pragma once

#include "board.hpp"
#include "tetrominos.hpp"

class TetrominoFactory
{
public:                                                                            
    static std::unique_ptr<Tetromino> createTetromino()
    {
        char randomType = Tetromino::types.at(rand() % Tetromino::types.size()); // Randomly select one tetromino
        CellColorType randomColor = Tetromino::tetromino_colors.at(rand() % Tetromino::tetromino_colors.size());
        int y0 = TetrisBoard::normalizedY(rand());

        // No need to break as it returns directly
        switch (randomType)
        {
        /* Symmetric tetros */
        case 'I':
            return std::make_unique<TetrominoI>(0,y0, randomColor);
        case 'O':
            return std::make_unique<TetrominoO>(0,y0, randomColor);
        case 'T':
            return std::make_unique<TetrominoT>(0,y0, randomColor);

        /* Asymmetric tetros */
        /* L - J */
        case 'L':
            return std::make_unique<TetrominoL>(0,y0, randomColor);
        case 'J':
            // Create J from L inverted
            return std::make_unique<TetrominoL>(0,y0, randomColor, true);

        /* S - Z */
        case 'S':
            return std::make_unique<TetrominoS>(0,y0, randomColor);
        case 'Z':
            // Create Z from S inverted
            return std::make_unique<TetrominoS>(0,y0, randomColor, true);

        default:
            throw std::invalid_argument("Invalid Tetromino type");
        }
    }
};


// File: ./include/server/game/Cell.hpp
#pragma once

#include "CellColorType.hpp"

enum CELL_STATES
{
    CELL_FALLED = -1,
    CELL_EMPTY = 0,
    CELL_FALLING = 1
};

class Cell
{
private:
    int state; // 0 = vazio, -1 = fixado, 1 = em queda
    CellColorType color;

    int x; // Linha (posição X)
    int y; // Coluna (posição Y)
public:
    Cell(int x, int y);

    CellColorType getColor() const { return color; };

    bool isEmpty() const;
    bool isFalling() const;
    bool isFixed() const;

    void setEmpty();
    void setFalling(const CellColorType &newColor);
    void setFixed(const CellColorType &newColor);

    bool operator==(const Cell &other) const
    {
        return color == other.color;
    }

    bool operator!=(const Cell &other) const
    {
        return !(*this == other);
    }
};


// File: ./include/server/game/tetrominos.hpp
#pragma once

#include "nonSymmetricTetromino.hpp"
#include <memory>    // for std::unique_ptr
#include <stdexcept> // for std::invalid_argument

/*
    Class for Tetromino I (Straight piece)
*/
class TetrominoI : public Tetromino
{
public:
    TetrominoI(int x0, int y0, CellColorType color) : Tetromino(x0, y0, color)
    {
        shape = {{1, 1, 1, 1}}; // 4-block straight line
    }
};

/*
    Tetromino O (Square piece)
*/
class TetrominoO : public Tetromino
{
public:
    TetrominoO(int x0, int y0, CellColorType color) : Tetromino(x0, y0, color)
    {
        shape = {{1, 1},
                 {1, 1}}; // 2x2 square
    }
};

/*
    Class for Tetromino T (T-pose piece)
*/
class TetrominoT : public Tetromino
{
public:
    TetrominoT(int x0, int y0, CellColorType color) : Tetromino(x0, y0, color)
    {
        shape = {{1, 1, 1}, 
                 {0, 1, 0}}; // T
    }
};

/*
    Tetromino L (Orange L-shaped piece)
*/
class TetrominoL : public NonSymmetricTetromino
{
public:
    TetrominoL(int x0, int y0, CellColorType color, bool inverted = false) : NonSymmetricTetromino(x0, y0, color, inverted)
    {
        shape = {{1, 0},
                 {1, 0},
                 {1, 1}};

        if (inverted)
            this->invertShape();
    }
};

/*
    Tetromino S (Green S-shaped piece)
*/
class TetrominoS : public NonSymmetricTetromino
{
public:
    TetrominoS(int x0, int y0, CellColorType color, bool inverted = false) : NonSymmetricTetromino(x0, y0, color, inverted)
    {
        shape = {{0, 1, 1},
                 {1, 1, 0}};

        if (inverted)
            this->invertShape();
    }
};


// File: ./include/server/Player.hpp
#pragma once
#include "PlayerData.hpp"
#include <iostream>

class Player
{
public:
    // Construct a player with a given ID and name.
    // The server sets initial states such as score = 0 and isConnected = true when they join.
    Player(int id, const std::string &name)
    {
        data.playerID = id;
        data.playerName = name;
        data.score = 0;
        data.isConnected = true;
    }

    ~Player()
    {
        std::cout << "Player " << data.playerID << " was deleted " << std::endl;
    }

    // Access the player's read-only data.
    const PlayerData getData() const
    {
        return data;
    }

    // Modify player attributes. These methods are only run on the server,
    // ensuring the server remains the authority.
    void addScore(int amount)
    {
        data.score += amount;
        // The server can then notify all clients about the updated score
    }

    void setName(const std::string &newName)
    {
        data.playerName = newName;
        // Possibly broadcast name change to clients
    }

    void disconnect()
    {
        data.isConnected = false;
        // Handle cleanup, notify clients, etc.
    }

    bool isConnected() const
    {
        return data.isConnected;
    }

private:
    PlayerData data;
};



// File: ./include/server/ServerManager.hpp
#pragma once

#include <enet/enet.h>
#include <thread>
#include <map>

#include "NetworkManager.hpp"
#include "game/gameManager.hpp"
#include "Player.hpp"
#include <json.hpp>
#include <random>

class ServerManager : public NetworkManager
{
private:
    int getNextAvailablePlayerID();
    void broadcastPlayerList();
    void createPlayerAndLink(ENetPeer *peer);

protected:
    void onPeerConnect(ENetPeer *peer) override;
    void onPeerDisconnect(ENetPeer *peer) override;

public:
    ServerManager(uint16_t port = 12345);
    ~ServerManager() {};

    void start_game();
};



// File: ./include/client/TetrisCell.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <functional>
#include "CellColorType.hpp"

class TetrisCell
{
    sf::RectangleShape cellShape;
    std::function<void()> onClickCallback;

public:
    TetrisCell(sf::Vector2f size, sf::Vector2f position, sf::Color color)
    {
        cellShape.setSize(size);
        cellShape.setPosition(position);
        cellShape.setFillColor(color);
        cellShape.setOutlineThickness(1.0f);
        cellShape.setOutlineColor(sf::Color::Black);
    }

    void setOnClick(const std::function<void()> &callback) { onClickCallback = callback; }

    void handleEvent(const sf::Event &event)
    {
        if (event.type == sf::Event::MouseButtonPressed)
            if (cellShape.getGlobalBounds().contains(static_cast<float>(event.mouseButton.x), static_cast<float>(event.mouseButton.y)))
                if (onClickCallback)
                    onClickCallback();
    }

    void render(sf::RenderWindow &window) { window.draw(cellShape); }

    void setColor(const sf::Color &color) { cellShape.setFillColor(color); }

    sf::RectangleShape &getShape() { return cellShape; }

    static sf::Color getColorFromType(CellColorType type)
    {
        switch (type)
        {
        case CellColorType::Empty:
            return sf::Color(50, 50, 50);
        case CellColorType::Red:
            return sf::Color::Red;
        case CellColorType::Green:
            return sf::Color::Green;
        case CellColorType::Blue:
            return sf::Color::Blue;
        case CellColorType::Yellow:
            return sf::Color::Yellow;
        default:
            return sf::Color::Magenta;
        }
    }
};



// File: ./include/client/screens/GameScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>
#include <map>

#include "Screen.hpp"

class GameScreen : public Screen
{
    sf::Text gameText;

public:
    GameScreen()
    {
        gameText.setFont(defaultFont);
        gameText.setString("Game Screen");
        gameText.setCharacterSize(40);
        gameText.setFillColor(sf::Color::Green);
        gameText.setPosition(200, 200);
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape)
            std::cout << "Game event: escape pressed" << std::endl;
    }

    void update(float deltaTime) override
    {
    }

    void render(sf::RenderWindow &window) override
    {
        window.draw(gameText);
    }
};


// File: ./include/client/screens/LobbyScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <memory>
#include "Screen.hpp"

class LobbyScreen : public Screen
{
    Button mainText;

    Button startGameText;

    ClientManager &clientMan;

    const float circleRadius = 30.0f;
    const float padding = 100.0f;
    std::vector<Button> clickableTexts;

public:
    LobbyScreen(ClientManager &clientManager)
        : clientMan(clientManager),
          mainText(defaultFont, "Tetris Lobby", sf::Color::Blue, {230, 20}, 50),
          startGameText(defaultFont, "Start Game", sf::Color::Green, {230, 380}, 40)
    {
        startGameText.setOnClick([&clientManager]() {
            clientManager.request_game_start();
        });
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        startGameText.handleEvent(event);

        for (Button ct : clickableTexts)
            ct.handleEvent(event);
            
        if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape)
            std::cout << "Lobby event: escape pressed" << std::endl;
    }

    void update(float deltaTime) override
    {
        // Update logic for lobby screen (e.g., fetching player list from server)
    }

    void render(sf::RenderWindow &window) override
    {
        startGameText.render(window);
        mainText.render(window);

        int index = 0;
        int maxColumns = 5; // Max number of circles per row
        int numPlayers = clientMan.getDataPlayers().size();

        // Calculate the number of rows needed
        int rows = (numPlayers + maxColumns - 1) / maxColumns;

        // Calculate the total width and height of the grid
        float totalWidth = maxColumns * (2 * circleRadius + padding) - padding;
        float totalHeight = rows * (2 * circleRadius + padding) - padding;

        // Get window size
        sf::Vector2u windowSize = window.getSize();

        // Calculate starting position to center the grid
        float startX = (windowSize.x - totalWidth) / 2;
        float startY = (windowSize.y - totalHeight) / 2;

        clickableTexts.clear();
        for (auto &pd : clientMan.getDataPlayers())
        {
            sf::CircleShape circle(circleRadius);

            circle.setFillColor(sf::Color::Cyan);
            circle.setOutlineThickness(2.0f);
            circle.setOutlineColor(sf::Color::Black);

            // Calculate position for the circle
            float x = startX + (index % maxColumns) * (2 * circleRadius + padding);
            float y = startY + (index / maxColumns) * (2 * circleRadius + padding);

            // Set circle position
            circle.setPosition(x, y);
            window.draw(circle);

            // Create and position the text
            Button itext(
                defaultFont,
                pd.playerName + " " + std::to_string(pd.playerID),
                sf::Color::Red,
                {x - circleRadius, y + 2 * circleRadius}, 20); // Centered text below circle

            itext.render(window);
            itext.setOnClick([&]()
                             { std::cout << " clicked " << pd.playerID << std::endl; });

            clickableTexts.emplace_back(itext);

            index++;
        }
    }
};



// File: ./include/client/screens/MenuScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>
#include <map>

#include "Screen.hpp"
#include "Button.hpp"
#include "ClientManager.hpp"

constexpr float x_offset_screen = 80;
constexpr float y_offset_screen = 120;

class MenuScreen : public Screen
{
    Button titleText;
    Button connectText;
    Button quitText;
    ScreenManager &manager; // Reference to ScreenManager
    ClientManager &clientMan;

public:
    MenuScreen(ScreenManager &screenManager, ClientManager &clientManager)
        : titleText(defaultFont, "Main Menu", sf::Color::White, {x_offset_screen + 200, y_offset_screen + 50}, 40),
          connectText(defaultFont, "Connect", sf::Color::White, {x_offset_screen + 330, y_offset_screen + 200}, 25),
          quitText(defaultFont, "Quit", sf::Color::White, {x_offset_screen + 200, y_offset_screen + 200}, 25),
          manager(screenManager), clientMan(clientManager)
    {
        connectText.setOnClick([this]()
                               {
                                manager.setActiveScreen("waiting-connection");
                                clientMan.connect(); });

        quitText.setOnClick([this]()
                            { manager.quit(); });
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        connectText.handleEvent(event);
        quitText.handleEvent(event);
    }

    void update(float deltaTime) override
    {
        // Menu update logic
    }

    void render(sf::RenderWindow &window) override
    {
        titleText.render(window);
        connectText.render(window);
        quitText.render(window);
    }
};



// File: ./include/client/screens/WaitingConnectionScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>
#include <map>

#include "Screen.hpp"
#include "Button.hpp"
#include "ClientManager.hpp"

class WaitingConnectionScreen : public Screen
{
    Button titleText;
    Button backText;

    ScreenManager &screenMan;
    ClientManager &clientMan;
    static constexpr float x_offset_screen = 100.0f;
    static constexpr float y_offset_screen = 120.0f;

public:
    WaitingConnectionScreen(ScreenManager &screenManager, ClientManager &clientManager)
        : titleText(defaultFont, "Waiting for server...", sf::Color::White, {(x_offset_screen + 100.0f), (y_offset_screen + 50.0f)}, 40),
          backText(defaultFont, "Back", sf::Color::White, {(x_offset_screen + 300.0f), (y_offset_screen + 170.0f)}, 25),
          screenMan(screenManager), clientMan(clientManager)
    {
        backText.setOnClick([this]()
                            {   std::cout << "Getting back to main screen\n";
                                screenMan.setActiveScreen("main-menu");
                                clientMan.disconnect(); });
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        backText.handleEvent(event);
    }

    void update(float deltaTime) override
    {
        if (clientMan.IsConnected())
            screenMan.setActiveScreen("lobby");
    }

    void render(sf::RenderWindow &window) override
    {
        titleText.render(window);
        backText.render(window);
    }
};



// File: ./include/client/screens/Button.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <functional>

class Button : public sf::Text
{
    std::function<void()> onClickCallback;

public:
    Button(const sf::Font &font, const std::string &str, sf::Color color, sf::Vector2f position, int fontSize)
    {
        setFont(font);
        setString(str);
        setCharacterSize(fontSize);
        setFillColor(color);
        setPosition(position);
    }

    void setOnClick(const std::function<void()> &callback) { onClickCallback = callback; }

    void handleEvent(const sf::Event &event)
    {
        if (event.type == sf::Event::MouseButtonPressed)
            if (getGlobalBounds().contains(static_cast<float>(event.mouseButton.x), static_cast<float>(event.mouseButton.y)))
                if (onClickCallback)
                    onClickCallback();
    }

    void render(sf::RenderWindow &window) { window.draw(*this); }
};



// File: ./include/client/screens/Screen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>
#include <map>

// Base class for screens
class Screen
{
public:
    Screen()
    {
        // Load font
        if (!defaultFont.loadFromFile("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf"))
        {
            std::cerr << "Error loading font!" << std::endl;
        }
    }
    virtual ~Screen() {}
    virtual void handleEvent(sf::Event event, class ScreenManager &manager) = 0;
    virtual void update(float deltaTime) = 0;
    virtual void render(sf::RenderWindow &window) = 0;

    void stop()
    {
        running = false;
    }

protected:
    std::atomic<bool> running{true};
    sf::Font defaultFont;
};

// Screen Manager
class ScreenManager
{
    std::map<std::string, std::unique_ptr<Screen>> screens;
    Screen *activeScreen = nullptr;

    std::thread screenThread;
    std::mutex mtx;
    std::condition_variable cv;

    std::atomic<bool> threadRunning{false};

public:
    ~ScreenManager()
    {
        stopThread();
    }

    void quit()
    {
        exit(0);
    }

    void addScreen(const std::string &name, std::unique_ptr<Screen> screen)
    {
        screens[name] = std::move(screen);
    }

    void setActiveScreen(const std::string &name)
    {
        {
            std::lock_guard<std::mutex> lock(mtx);
            activeScreen = screens[name].get();
        }
        cv.notify_one();
    }

    void handleEvent(sf::Event event)
    {
        if (activeScreen)
        {
            activeScreen->handleEvent(event, *this);
        }
    }

    void update(float deltaTime)
    {
        if (activeScreen)
        {
            activeScreen->update(deltaTime);
        }
    }

    void render(sf::RenderWindow &window)
    {
        if (activeScreen)
            activeScreen->render(window);
    }

    void startThread()
    {
        threadRunning = true;
        screenThread = std::thread([this]()
                                   {
            while (threadRunning) {
                std::unique_lock<std::mutex> lock(mtx);
                cv.wait(lock, [this]() { return activeScreen != nullptr; });
                lock.unlock();

                while (threadRunning) {
                    if (activeScreen) {
                        activeScreen->update(0.016f); // Simulate ~60 FPS updates
                    }
                    std::this_thread::sleep_for(std::chrono::milliseconds(16));
                }
            } });
    }

    void stopThread()
    {
        threadRunning = false;
        if (screenThread.joinable())
        {
            screenThread.join();
        }
    }
};


// File: ./include/client/screens/BoardScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <vector>
#include <memory>
#include <string>
#include "Screen.hpp"
#include "TetrisCell.hpp"

class BoardScreen : public Screen
{
private:
    int BOARD_WIDTH = 10;
    int BOARD_HEIGHT = 10;
    int CELL_SIZE = 30;
    ClientManager &clientManager;

    std::vector<std::vector<std::shared_ptr<TetrisCell>>> grid;

    void setupCells()
    {
        for (int y = 0; y < BOARD_HEIGHT; ++y)
        {
            std::vector<std::shared_ptr<TetrisCell>> row;
            for (int x = 0; x < BOARD_WIDTH; ++x)
            {
                auto cell = std::make_shared<TetrisCell>(
                    sf::Vector2f(CELL_SIZE, CELL_SIZE),
                    sf::Vector2f(x * CELL_SIZE, y * CELL_SIZE),
                    sf::Color::Red);

                row.push_back(cell);
            }
            grid.push_back(row);
        }
    }

public:
    BoardScreen(ClientManager &clientManager) : clientManager(clientManager)
    {
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        handleKeyPress(event);

        for (auto &row : grid)
            for (auto &cell : row)
                cell->handleEvent(event);
    }

    void render(sf::RenderWindow &window) override
    {
        for (auto &row : grid)
            for (auto &cell : row)
                cell->render(window);
    }

    void updateBoardFromJson(const nlohmann::json &boardData)
    {
        // Check for required keys in the JSON
        if (!boardData.contains("width") || !boardData.contains("height") || !boardData.contains("cells"))
        {
            std::cerr << "Error: JSON is missing required keys (width, height, or cells)" << std::endl;
            return;
        }

        // Check that width and height are valid integers
        if (!boardData.at("width").is_number_integer() || !boardData.at("height").is_number_integer())
        {
            std::cerr << "Error: JSON width or height is not an integer" << std::endl;
            return;
        }

        // Extract width and height
        int newWidth = boardData.at("width").get<int>();
        int newHeight = boardData.at("height").get<int>();

        // Check that cells is a valid 2D array
        if (!boardData.at("cells").is_array() || boardData.at("cells").size() != newHeight)
        {
            std::cerr << "Error: JSON cells array does not match the specified height" << std::endl;
            return;
        }

        for (const auto &row : boardData.at("cells"))
        {
            if (!row.is_array() || row.size() != newWidth)
            {
                std::cerr << "Error: JSON cells array does not match the specified width" << std::endl;
                return;
            }
        }

        // Proceed with processing the data
        if ((int)grid.size() != newHeight || (int)grid.at(0).size() != newWidth)
        {
            BOARD_WIDTH = newWidth;
            BOARD_HEIGHT = newHeight;
            grid.clear();
            setupCells();
        }

        // Update cell colors
        auto cells = boardData.at("cells");
        for (int y = 0; y < BOARD_HEIGHT; y++)
        {
            for (int x = 0; x < BOARD_WIDTH; x++)
            {
                sf::Color cellColor = sf::Color::White;

                // Check if cell contains "c" and process color
                if (cells[y][x].contains("c"))
                {
                    cellColor = TetrisCell::getColorFromType(cells[y][x]["c"]);
                    grid.at(y).at(x)->setColor(cellColor);
                }
            }
        }
    }

    void update(float deltaTime) override
    {
        if (clientManager.boardDataAvailable())
        {
            nlohmann::json newBoard = clientManager.getLastBoardState();
            updateBoardFromJson(newBoard);
        }
    }

    void handleKeyPress(sf::Event event)
    {
        if (event.type == sf::Event::KeyPressed)
            clientManager.onPressKey(event.key);
    }
};



// File: ./include/client/ClientManager.hpp
#pragma once

#include <iostream>
#include "NetworkManager.hpp"
#include <SFML/Graphics.hpp>
#include "PlayerData.hpp"
#include <thread>
#include <atomic>
#include <mutex>

class ClientManager : public NetworkManager
{
private:
    ENetPeer *serverPeer;
    std::atomic<bool> isConnected = false;

    std::vector<PlayerData> players;

    std::thread ThreadHeartbeat;
    std::atomic<bool> HeartBeatRunningFlag = false;
    unsigned long last_heartbeat;

    bool debugEnabled = false;
    
    std::mutex boardMutex;
    nlohmann::json lastReceivedBoard;
    bool hasBoardData = false;

protected:
    void onPeerConnect(ENetPeer *peer) override;
    void onPeerDisconnect(ENetPeer *peer) override;

public:
    ClientManager() {};
    ~ClientManager() {};

    void toggleDebug();

    void on_receive_heartbeat();
    void on_receive_player_list(const Packet &packet);
    void on_receive_game_screen(const Packet &packet);

    void TaskStartHeartbeat();
    void TaskHeartbeat();
    void TaskStopHeartbeat();

    void connect(const std::string &serverAddress = "localhost", uint16_t port = 12345);
    void disconnect();

    bool IsConnected() const { return isConnected; };
    std::vector<PlayerData> &getDataPlayers() { return players; }

    nlohmann::json getLastBoardState();

    bool boardDataAvailable();
    void request_game_start();

    void onPressKey(sf::Event::KeyEvent e);
};


// File: ./src/common/NetworkManager.cpp
#include "NetworkManager.hpp"
#include <iomanip>
#include <iostream>
#include <thread>

char *NetworkManager::uint32_to_ipv4(uint32_t ip_addr)
{
    // Allocate memory for the resulting IP address string (e.g., "255.255.255.255\0" is 16 characters)
    static char ip_str[16];

    // Convert from host byte order to network byte order
    ip_addr = htonl(ip_addr);

    // Break the integer into its four bytes and format as an IPv4 address string
    snprintf(ip_str, sizeof(ip_str), "%u.%u.%u.%u",
             (ip_addr >> 24) & 0xFF,
             (ip_addr >> 16) & 0xFF,
             (ip_addr >> 8) & 0xFF,
             ip_addr & 0xFF);

    return ip_str;
}
NetworkManager::NetworkManager()
{
    if (enet_initialize() != 0)
    {
        std::cerr << "Failed to initialize ENET!" << std::endl;
        throw std::runtime_error("Failed to initialize ENet.");
    }
}

NetworkManager::~NetworkManager()
{
    TaskStopNetwork();
}

void NetworkManager::send_packet(const Packet &packet)
{
    outgoingPackets.push(packet);
}

void NetworkManager::network_print(const char *array)
{
    // Get current time as time_t (seconds since epoch)
    auto now = std::chrono::system_clock::now();
    std::time_t currentTime = std::chrono::system_clock::to_time_t(now);

    // Convert time_t to local time (struct tm)
    std::tm *localTime = std::localtime(&currentTime);
    std::cout << "[" << std::put_time(localTime, "%H:%M:%S") << "] " << array;
}

void NetworkManager::TaskStartNetwork()
{
    if (running)
    {
        std::cout << "Error: Network Task already running! (Why would you start again?)" << std::endl;
        return;
    }

    network_print("Initializing Network Task...\n");
    running = true;
    networkThread = std::thread(&NetworkManager::TaskNetwork, this);
}

void NetworkManager::registerListener(PacketType packetType, std::function<void(const Packet &)> callback)
{
    listeners[static_cast<uint8_t>(packetType)] = callback;
}

void NetworkManager::handlePacket(Packet &packet, ENetPeer *peer)
{
    uint8_t packetType = static_cast<uint8_t>(packet.type);
    if (listeners.find(packetType) != listeners.end())
    {
        packet.peer = peer;
        listeners[packetType](packet); // Pass both packet and the source peer
    }
    else
    {
        network_print("");
        std::cout << "[" << uint32_to_ipv4(peer->address.host) << ":" << peer->address.port << "]" << " >> \"" << PacketTypeToString(packet.type) << "\" (No listener registred)\n";
    }
}

void NetworkManager::processIncomingPackets()
{
    while (!incommingPackets.empty())
    {
        Packet packet = incommingPackets.front();
        incommingPackets.pop();
        handlePacket(packet, packet.peer);
    }
}

void NetworkManager::TaskStopNetwork()
{
    running = false;

    if (networkThread.joinable())
        networkThread.join();
}

bool NetworkManager::isRunning() const
{
    return running;
}

Packet NetworkManager::parsePacket(const ENetPacket *enetPacket, ENetPeer *sourcePeer)
{
    if (enetPacket->dataLength < 1)
    {
        network_print("Failed to parse a packet from ");
        std::cout << uint32_to_ipv4(sourcePeer->address.host) << ":" << sourcePeer->address.port << std::endl;

        return Packet(PacketType::PARSING_ERROR, 0, sourcePeer);
    }
    PacketType type = static_cast<PacketType>(enetPacket->data[0]);                             // First byte is the packet type
    std::vector<uint8_t> data(enetPacket->data + 1, enetPacket->data + enetPacket->dataLength); // Remaining data
    return Packet(type, data, sourcePeer);
}

ENetPacket *NetworkManager::createENetPacket(const Packet &packet)
{
    std::vector<uint8_t> rawData = packet.toRawData();
    return enet_packet_create(rawData.data(), rawData.size(), ENET_PACKET_FLAG_RELIABLE);
}

void NetworkManager::TaskNetwork()
{
    int network_frequencie = 20; // Hertz
    while (running)
    {
        ENetEvent event;

        while (enet_host_service(host, &event, (1000 / network_frequencie)) > 0)
            processENetEvent(event);

        sendOutgoingPackets();
        processIncomingPackets();
    }
    enet_host_destroy(host);
}

void NetworkManager::sendOutgoingPackets()
{
    while (!outgoingPackets.empty())
    {
        Packet packet = outgoingPackets.front();
        outgoingPackets.pop();

        if (packet.peer)
        {
            ENetPacket *enetPacket = createENetPacket(packet);
            enet_peer_send(packet.peer, 0, enetPacket);
        }
        else
        {
            std::vector<uint8_t> rawData = packet.toRawData();
            for (size_t i = 0; i < host->peerCount; ++i)
            {
                ENetPacket *enetPacket = enet_packet_create(rawData.data(), rawData.size(), ENET_PACKET_FLAG_RELIABLE);
                enet_peer_send(&host->peers[i], 0, enetPacket);
            }
        }
    }
}

void NetworkManager::processENetEvent(ENetEvent &event)
{
    switch (event.type)
    {
    case ENET_EVENT_TYPE_CONNECT:
    {
        onPeerConnect(event.peer);
        break;
    }

    case ENET_EVENT_TYPE_RECEIVE:
    {
        Packet packet = parsePacket(event.packet, event.peer);
        handlePacket(packet, event.peer);
        enet_packet_destroy(event.packet);
    }
    break;

    case ENET_EVENT_TYPE_DISCONNECT:
    {
        onPeerDisconnect(event.peer);
        break;
    }
    default:
    {
        std::cout << "[ENET] EventType = " << event.type << std::endl;
        break;
    }
    }
}

ENetHost *NetworkManager::getHost() { return host; }

std::vector<ENetPeer *> NetworkManager::getPeers()
{
    std::vector<ENetPeer *> peers;
    if (!host)
        return peers; // If host is not initialized, just return empty.

    for (size_t i = 0; i < host->peerCount; ++i)
    {
        ENetPeer &p = host->peers[i];
        // Only consider peers that are fully connected
        if (p.state == ENET_PEER_STATE_CONNECTED)
        {
            peers.push_back(&p);
        }
    }
    return peers; // Return by value, so the caller gets a valid copy.
}



// File: ./src/server/TetrisServer.cpp
#include <enet/enet.h>
#include <iostream>
#include "ServerManager.hpp"
#include "TetrisAction.hpp"

ServerManager server(12345);
GameManager gm(server);

// Might get player from packt id
void onReceiveArrow(const Packet &packet)
{
    TetrisAction action = getActionFromPacketType(packet.type);
    gm.enqueueAction(action);
}

void HeartbeatListener(const Packet &packet)
{
    server.send_packet(packet);
}

void StartGameListener(const Packet &packet)
{
    server.start_game();
    gm.startGameLoop();
}

void JoinRequestListener(const Packet &packet)
{
    if (server.getHost()->connectedPeers < 4)
        server.send_packet(Packet(PacketType::JOIN_ACCEPTED, 0, packet.peer));
    else
        server.send_packet(Packet(PacketType::JOIN_DENIED, 0, packet.peer));
}

int main(int argc, const char *argv[])
{
    if (server.isRunning())
        server.network_print("Waiting connections...\n");
    else
        return -1;

    server.registerListener(PacketType::JOIN_REQUEST, JoinRequestListener);
    server.registerListener(PacketType::HEARTBEAT, HeartbeatListener);
    server.registerListener(PacketType::REQUEST_START, StartGameListener);

    server.registerListener(PacketType::LEFT, onReceiveArrow);
    server.registerListener(PacketType::RIGHT, onReceiveArrow);
    server.registerListener(PacketType::ROTATE_LEFT, onReceiveArrow);
    server.registerListener(PacketType::ROTATE_RIGHT, onReceiveArrow);
    server.registerListener(PacketType::DROP_FASTER, onReceiveArrow);
    server.registerListener(PacketType::DROP_INSTANT, onReceiveArrow);

    while (server.isRunning())
        std::this_thread::sleep_for(std::chrono::milliseconds(10));

    return 0;
}



// File: ./src/server/ServerManager.cpp
#include "ServerManager.hpp"
#include <iostream>
#include <stdexcept>

#define MAX_CLIENTS 32
#define CHANNELS 2

void ServerManager::onPeerConnect(ENetPeer *peer)
{
    network_print("");
    std::cout << "[CONNECTED] " << uint32_to_ipv4(peer->address.host) << ":" << peer->address.port << std::endl;

    createPlayerAndLink(peer);
    broadcastPlayerList();
}
void ServerManager::onPeerDisconnect(ENetPeer *peer)
{
    network_print("");
    std::cout << "[DISCONNECTED] " << uint32_to_ipv4(peer->address.host) << ":" << peer->address.port << std::endl;
    delete (Player *)peer->data;
    broadcastPlayerList();
}

ServerManager::ServerManager(uint16_t port)
{
    std::cout << std::endl;
    std::cout << "╭───────────────────────────────────────╮" << std::endl;
    std::cout << "│          Starting Tetris Server       │" << std::endl;
    std::cout << "├───────────────────────────────────────┤" << std::endl;
    std::cout << "│   Using NetworkManager version v" << NetworkManager::version << "     │" << std::endl;
    std::cout << "│   Opening server at port " << port << "        │" << std::endl;
    std::cout << "╰───────────────────────────────────────╯" << std::endl;
    std::cout << std::endl;

    ENetAddress address;
    enet_address_set_host(&address, "0.0.0.0");
    address.port = port;

    try
    {
        host = enet_host_create(&address, MAX_CLIENTS, CHANNELS, 0, 0);
        if (!host)
            throw std::runtime_error("Failed to create ENet server host. Is it already running? (Port busy)");
    }
    catch (const std::exception &ex)
    {
        std::cerr << "Error: " << ex.what() << std::endl;
        return;
    }

    TaskStartNetwork();
}

int ServerManager::getNextAvailablePlayerID()
{
    static int currentID = 0;
    return currentID++;
}

void ServerManager::createPlayerAndLink(ENetPeer *peer)
{
    Player *newPlayer = new Player(getNextAvailablePlayerID(), "Unnamed");
    peer->data = (void *)newPlayer;
    std::cout << "New client connected. Assigned PlayerID: " << newPlayer->getData().playerID << "\n";
}

void ServerManager::broadcastPlayerList()
{
    nlohmann::json message = nlohmann::json::array();

    for (ENetPeer *entry : getPeers())
    {
        if (!entry->data)
        {
            // This peer doesn't have a Player associated yet, skip it
            std::cout << "~No player~" << std::endl;
            continue;
        }
        Player *player = (Player *)entry->data;

        nlohmann::json playerJson = player->getData().serialize();

        message.push_back(nlohmann::json::array({playerJson}));
    }
    std::cout << message << std::endl;
    send_packet(Packet(PacketType::PLAYER_LIST, message, nullptr));
}

void ServerManager::start_game()
{
    send_packet(Packet(PacketType::STARTING_GAME, 0, nullptr));
}


// File: ./src/server/game/gameManager.cpp
#include "game/gameManager.hpp"
#include <cstdlib>
#include <ctime>
#include <algorithm> // for std::max, std::min

#define P(x) ((280 * (x * x * x) - 1470 * (x * x) + 2630 * (x) - 1320) / 3)
#define LEVEL_UP 10
#define DOWN_FASTER 2 // Define this appropriately if not defined elsewhere

GameManager::GameManager(ServerManager &serverManager)
    : board(serverManager),
      isRunning(false),
      score(0),
      level(0),
      nLinesClearedThisLevel(0),
      levelUpGravityTimeMs(100),
      threadActive(false)
{
    // Initialize gravityTimeMs to a default, for example 800ms:
    gravityTimeMs = 600;
}

int GameManager::lines2Points(int nLines)
{
    return (nLines > 0) ? P(std::min(nLines, 4)) * (level + 1) : 0;
}

void GameManager::startGameLoop()
{
    if (isRunning.load())
    {
        std::cerr << "Game is already running!" << std::endl;
        return;
    }

    isRunning.store(true);
    threadActive.store(true);
    // Spawn a new thread that runs runGameLoop()
    gameThread = std::thread(&GameManager::runGameLoop, this);
    std::cout << "Game Started!";
}

void GameManager::stopGameLoop()
{
    // Signal the loop to stop
    isRunning.store(false);

    // Wait for thread to finish if joinable
    if (gameThread.joinable())
    {
        gameThread.join();
    }
}

bool GameManager::isGameRunning() const
{
    return isRunning.load();
}

bool GameManager::isThreadRunning() const
{
    return threadActive.load();
}

void GameManager::spawnTetromino()
{
    currentTetromino = TetrominoFactory::createTetromino();
}

void GameManager::runGameLoop()
{
    srand(time(NULL));
    spawnTetromino();

    // Initialize lastGravityTick
    lastGravityTick = std::chrono::steady_clock::now();

    while (isRunning)
    {
        TetrisAction action;
        while (actionQueue.pop(action))
            handleInput(action);
    
        update();
        board.broadcastBoardState();
        // board.printStatus();
        //  Sleep a bit to avoid busy-waiting and allow input handling at ~60 FPS
        std::this_thread::sleep_for(std::chrono::milliseconds(25));
    }

    // Loop ended
    threadActive.store(false);
}

void GameManager::update()
{
    std::lock_guard<std::mutex> lock(gameStateMutex);

    if (board.reachedTop())
    {
        std::cout << "(GAME OVER) !!!" << std::endl;
        std::cout << "(Final score) : " << score << " !!!" << std::endl;
        std::cout << "You played till level: " << level << std::endl;

        board.clear();
        // Exit game loop by setting isRunning to false
        isRunning.store(false);
        return; // Return here to stop processing
    }

    // Clear old tetrominos
    board.clearFallingTetrominos();

    TetrisAction lastMovereceived = this->lastM;

    // Check if it's time to apply gravity
    auto now = std::chrono::steady_clock::now();
    if (std::chrono::duration_cast<std::chrono::milliseconds>(now - lastGravityTick).count() > gravityTimeMs)
    {
        currentTetromino->dropGravity();
        lastGravityTick = now;
        lastMovereceived = TetrisAction::EMPTY;
    }
    else
    {
        this->lastM = TetrisAction::EMPTY;
    }

    // Check collision after gravity or moves
    if (board.checkCollision(*currentTetromino, lastMovereceived))
    {
        if (lastMovereceived == TetrisAction::DROP_FASTER || currentTetromino->getGravity())
        {
            // Place and lock tetromino
            std::cout << "Last move received = " << TetrisActionToString(lastMovereceived) << " e gravidade = " << currentTetromino->getGravity() << std::endl;
            board.placeTetromino(*currentTetromino, true);

            // GRAVIDADE TEM Q SAIR DO TETROMINO, é uyma propriedade GLOBAL agr
            currentTetromino->gravity = false;

            // std::cout << "Encaixei" << std::endl;
            currentTetromino.reset();

            nLinesClearedThisLevel += board.clearLines();
            score += lines2Points(nLinesClearedThisLevel);

            if (nLinesClearedThisLevel >= LEVEL_UP)
            {
                level++;
                // Clear all fixed blocks
                board.clearFalledTetrominos();

                gravityTimeMs = std::max(gravityTimeMs - levelUpGravityTimeMs, minTimeMs);
                lastGravityTick = std::chrono::steady_clock::now();
                nLinesClearedThisLevel = 0;
                std::cout << "(Current score) : " << score << " !!!" << std::endl;
                std::cout << "(LEVEL UP) !!!" << std::endl;
            }

            // Spawn a new tetromino
            spawnTetromino();
        }
        else
        {
            // Invalid move, revert
            board.placeTetromino(*currentTetromino, false);
            currentTetromino->gravity = false;
        }
    }
    else
    {
        // Valid move, place without locking
        board.placeTetromino(*currentTetromino, false);
        currentTetromino->gravity = false;
    }
}

void GameManager::handleInput(TetrisAction action)
{
    std::lock_guard<std::mutex> lock(gameStateMutex);
    lastM = action;
}



// File: ./src/server/game/cell.cpp
#include "game/Cell.hpp"

Cell::Cell(int x, int y) : x(x), y(y) { setEmpty(); }

bool Cell::isEmpty() const { return state == CELL_EMPTY; }
bool Cell::isFalling() const { return state == CELL_FALLING; }

bool Cell::isFixed() const { return state == CELL_FALLED; }

void Cell::setEmpty()
{
    state = CELL_EMPTY;
    color = CellColorType::Empty;
}

void Cell::setFalling(const CellColorType &newColor)
{
    state = CELL_FALLING;
    color = newColor;
}

void Cell::setFixed(const CellColorType &newColor)
{
    state = CELL_FALLED;
    color = newColor;
}



// File: ./src/server/game/board.cpp
#include "game/board.hpp"
#include <stdlib.h>
#include "ServerManager.hpp"

const int TetrisBoard::WIDTH = 10;
const int TetrisBoard::HEIGHT = 16;

TetrisBoard::TetrisBoard(ServerManager &serverManager) : serverManager(serverManager)
{
    for (int y = 0; y < HEIGHT; ++y)
    {
        std::vector<std::shared_ptr<Cell>> row;

        for (int x = 0; x < WIDTH; ++x)
        {
            auto cell = std::make_shared<Cell>(x, y);
            row.push_back(cell);
        }

        grid.push_back(row);
    }
}

bool TetrisBoard::reachedTop()
{
    for (int y = 0; y < WIDTH; ++y)
    {
        if (grid.at(0).at(y)->isFixed())
            return true;
    }

    return false;
}

void TetrisBoard::printStatus()
{
    system("clear");

    // Imprimir status da board
    std::cout << "\nEstado da Board:" << std::endl;
    for (int x = 0; x < HEIGHT; x++)
    {
        for (int y = 0; y < WIDTH; y++)
        {
            std::cout << (grid[x][y]->isFalling() ? " # " : (grid[x][y]->isEmpty()) ? " * "
                                                                                    : " $ ");
        }
        std::cout << std::endl;
    }

    // Separador visual
    std::cout << std::string(40, '-') << std::endl;
}

void TetrisBoard::clear()
{
    for (int x = 0; x < HEIGHT; x++)
    {
        for (int y = 0; y < WIDTH; y++)
        {
            grid[x][y]->setEmpty();
        }
    }
}

std::vector<std::vector<std::shared_ptr<Cell>>> &TetrisBoard::getGrid()
{
    return grid;
}

bool TetrisBoard::checkCollision(Tetromino &currentTetromino, TetrisAction lastMove)
{
    currentTetromino.evolveStates(true, lastMove);

    const auto &shape = currentTetromino.getShape();

    int tetrominoX = currentTetromino.getX();
    int tetrominoY = currentTetromino.getY();

    for (size_t x = 0; x < shape.size(); ++x)
    {
        for (size_t y = 0; y < shape[x].size(); ++y)
        {
            if (shape[x][y] != 0)
            {
                int gridX = tetrominoX + x;
                int gridY = normalizedY(tetrominoY + y);

                if (gridX >= HEIGHT || gridX < 0)
                {
                    currentTetromino.evolveStates(false, lastMove);
                    return true;
                }

                if (grid[gridX][gridY]->isFixed())
                {
                    currentTetromino.evolveStates(false, lastMove);
                    return true;
                }
            }
        }
    }

    return false;
}

int TetrisBoard::normalizedY(int y)
{
    y %= WIDTH;

    if (y < 0)
        y += WIDTH;

    return y;
}

// Integra o tetromino com o resto que já caiu
bool TetrisBoard::placeTetromino(const Tetromino &currentTetromino, bool bottom)
{

    const auto &shape = currentTetromino.getShape();

    for (size_t x = 0; x < shape.size(); ++x)
    {
        for (size_t y = 0; y < shape[x].size(); ++y)
        {
            if (shape[x][y] != 0)
            {
                int gridX = currentTetromino.getX() + x;
                int gridY = normalizedY(currentTetromino.getY() + y);
                CellColorType tetroColor = currentTetromino.getColor();

                if (bottom)
                    grid[gridX][gridY]->setFixed(tetroColor);
                else
                    grid[gridX][gridY]->setFalling(tetroColor);
            }
        }
    }

    return true;
}

void TetrisBoard::clearFallingTetrominos()
{
    for (int x = 0; x < HEIGHT; ++x)
    {
        for (int y = 0; y < WIDTH; ++y)
        {
            if (grid[x][y]->isFalling())
            {
                grid[x][y]->setEmpty();
            }
        }
    }
}

void TetrisBoard::clearFalledTetrominos()
{
    for (int x = 0; x < HEIGHT; ++x)
    {
        for (int y = 0; y < WIDTH; ++y)
        {
            if (grid[x][y]->isFixed())
            {
                grid[x][y]->setEmpty();
            }
        }
    }
}

int TetrisBoard::clearLines()
{
    int numLinesCleared = 0;

    // De baixo pra cima
    for (int x = HEIGHT - 1; x >= 0; --x)
    {
        int sumLine = 0;
        for (int y = 0; y < WIDTH; ++y)
        {
            if (grid[x][y]->isFixed())
                sumLine++;
        }

        // ------- Clear -------
        if (sumLine == WIDTH)
        {
            // 1 - Mudar o estado de todas as celulas daquela linha pra empty
            for (int y = 0; y < WIDTH; ++y)
            {
                grid[x][y]->setEmpty();
            }

            // 2 - Carregar todos os fixos dali pra cima "pra baixo"
            for (int x_clear = x; x_clear >= 1; --x_clear)
            {
                for (int y = 0; y < WIDTH; ++y)
                {

                    // Se o de cima for algum bloco fixo
                    if (grid[x_clear - 1][y]->isFixed())
                    {

                        // Setar o de baixo como fixo, com a cor do de cima
                        grid[x_clear][y]->setFixed(grid[x_clear - 1][y]->getColor());

                        // E deixar oq foi mudado como vazio
                        grid[x_clear - 1][y]->setEmpty();
                    }
                }
            }

            x++;
            numLinesCleared++;
        }
    }

    return numLinesCleared;
}

void TetrisBoard::broadcastBoardState()
{
    if (!gridsAreEqual(grid, lastBroadcastedGrid))
    {
        updateLastBroadcastedGrid();                     // Step 1: Update lastBroadcastedGrid to match the current grid
        nlohmann::json boardJson = constructBoardJson(); // Step 2: Construct the JSON object
        sendBoardState(boardJson);                       // Step 3: Broadcast the JSON object
    }
}

// Updates lastBroadcastedGrid with a deep copy of the current grid
void TetrisBoard::updateLastBroadcastedGrid()
{
    lastBroadcastedGrid.clear();
    lastBroadcastedGrid.reserve(grid.size());

    for (const auto &row : grid)
    {
        std::vector<std::shared_ptr<Cell>> newRow;
        newRow.reserve(row.size());

        for (const auto &cellPtr : row)
        {
            if (cellPtr)
            {
                newRow.emplace_back(std::make_shared<Cell>(*cellPtr));
            }
            else
            {
                newRow.emplace_back(nullptr);
            }
        }

        lastBroadcastedGrid.emplace_back(std::move(newRow));
    }
}

// Constructs a JSON representation of the board's current state
nlohmann::json TetrisBoard::constructBoardJson() const
{
    nlohmann::json boardJson;
    boardJson["width"] = WIDTH;
    boardJson["height"] = HEIGHT;

    nlohmann::json cells = nlohmann::json::array();

    for (int y = 0; y < HEIGHT; ++y)
    {
        nlohmann::json row = nlohmann::json::array();
        for (int x = 0; x < WIDTH; ++x)
        {
            CellColorType colorType = grid.at(y).at(x)->getColor();

            nlohmann::json cellObj;
            cellObj["c"] = colorType;
            row.push_back(cellObj);
        }
        cells.push_back(row);
    }

    boardJson["cells"] = cells;
    return boardJson;
}

// Sends the JSON board state using the server manager
void TetrisBoard::sendBoardState(const nlohmann::json &boardJson) const
{
    serverManager.send_packet(Packet(PacketType::GAME_SCREEN, boardJson, nullptr));
}

// Implementation of gridsAreEqual
bool TetrisBoard::gridsAreEqual(const std::vector<std::vector<std::shared_ptr<Cell>>> &grid1,
                                const std::vector<std::vector<std::shared_ptr<Cell>>> &grid2) const
{
    if (grid1.size() != grid2.size())
        return false;

    for (size_t i = 0; i < grid1.size(); ++i)
    {
        if (grid1[i].size() != grid2[i].size())
            return false;

        for (size_t j = 0; j < grid1[i].size(); ++j)
        {
            // Handle nullptrs if cells can be null
            if (grid1[i][j] == nullptr && grid2[i][j] == nullptr)
                continue;
            if ((grid1[i][j] == nullptr) != (grid2[i][j] == nullptr))
                return false;
            if (*grid1[i][j] != *grid2[i][j])
                return false;
        }
    }

    return true;
}


// File: ./src/server/game/baseTetromino.cpp
#include "game/baseTetromino.hpp"

const std::vector<CellColorType> Tetromino::tetromino_colors = {
    CellColorType::Red,
    CellColorType::Blue,
    CellColorType::Yellow,
    CellColorType::Green};

const std::vector<char> Tetromino::types = {'I', 'O', 'T', 'L', 'J', 'S', 'Z'};

int Tetromino::getX() const
{
    return x;
}

int Tetromino::getY() const
{
    return y;
}

CellColorType Tetromino::getColor() const
{
    return color;
}

bool Tetromino::getGravity() const
{
    return gravity;
}

const std::vector<std::vector<int>> &Tetromino::getShape() const
{
    return shape;
}

void Tetromino::evolveStates(bool forward, TetrisAction lastMove)
{
    int sign = (forward) ? 1 : -1;

    if (gravity)
    {
        x += sign;
    }

    switch (lastMove)
    {

    case TetrisAction::LEFT:
        y -= sign;
        break;
    case TetrisAction::RIGHT:
        y += sign;
        break;
    case TetrisAction::DROP_FASTER:
        x += sign;
        break;

    default:
        break;
    }

    size_t rows = shape.size();
    size_t cols = shape[0].size();

    // Cria a matriz rotacionada
    std::vector<std::vector<int>> rotated(cols, std::vector<int>(rows));

    if ((lastMove == TetrisAction::ROTATE_LEFT && forward) || (lastMove == TetrisAction::ROTATE_RIGHT && !forward))
    {

        for (size_t i = 0; i < rows; ++i)
        {
            for (size_t j = 0; j < cols; ++j)
            {
                rotated[j][rows - i - 1] = shape[i][j];
            }
        }

        shape = rotated;
    }

    if ((lastMove == TetrisAction::ROTATE_RIGHT && forward) || (lastMove == TetrisAction::ROTATE_LEFT && !forward))
    {
        for (size_t i = 0; i < rows; ++i)
        {
            for (size_t j = 0; j < cols; ++j)
            {
                rotated[cols - j - 1][i] = shape[i][j];
            }
        }

        shape = rotated;
    }
}

void Tetromino::dropGravity()
{
    gravity = true;
}


// File: ./src/client/ClientManager.cpp
#include "ClientManager.hpp"
#include <iostream>
#include <chrono>
#include <SFML/Graphics.hpp>
#include "PlayerData.hpp"

void ClientManager::onPeerConnect(ENetPeer *peer)
{
    isConnected = true;
    std::cout << std::endl;
    network_print("");
    std::cout << "Connection successful to " << uint32_to_ipv4(peer->address.host) << ":" << peer->address.port << std::endl;
}
void ClientManager::onPeerDisconnect(ENetPeer *peer)
{
    isConnected = false;
    network_print("Disconnected from server\n");
    disconnect();
}

void ClientManager::on_receive_heartbeat()
{
    auto now = std::chrono::system_clock::now();
    auto now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    last_heartbeat = now_ms;
}

void ClientManager::on_receive_player_list(const Packet &packet)
{
    players.clear();

    nlohmann::json received;

    try
    {
        received = packet.toJson();
    }
    catch (const std::exception &e)
    {
        std::cerr << "Failed to parse packet as JSON: " << e.what() << std::endl;
        return;
    }

    if (!received.is_array())
    {
        std::cerr << "Invalid JSON: top-level element is not an array." << std::endl;
        return;
    }

    // Iterate over each inner array
    for (const auto &innerArray : received)
    {
        if (!innerArray.is_array())
        {
            std::cerr << "Inner element is not an array. Skipping." << std::endl;
            continue;
        }

        // Iterate over each player object in the inner arrays
        for (const auto &playerObject : innerArray)
        {
            if (!playerObject.is_object())
            {
                std::cerr << "Player entry is not a valid JSON object. Skipping." << std::endl;
                continue;
            }

            PlayerData playerData;

            if (playerObject.contains("isConnected") && playerObject["isConnected"].is_boolean())
                playerData.isConnected = playerObject["isConnected"].get<bool>();

            if (playerObject.contains("playerID") && playerObject["playerID"].is_number_integer())
                playerData.playerID = playerObject["playerID"].get<int>();

            if (playerObject.contains("playerName") && playerObject["playerName"].is_string())
                playerData.playerName = playerObject["playerName"].get<std::string>();

            if (playerObject.contains("score") && playerObject["score"].is_number_integer())
                playerData.score = playerObject["score"].get<int>();

            players.emplace_back(playerData);
        }
    }
}

void ClientManager::TaskStartHeartbeat()
{
    network_print("Initializing Heartbeat Task...\n");
    ThreadHeartbeat = std::thread(&ClientManager::TaskHeartbeat, this);
}

void ClientManager::TaskHeartbeat()
{
    HeartBeatRunningFlag = true;
    int heartbeat_frequencie = 1; // Hertz
    while (HeartBeatRunningFlag)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000 / heartbeat_frequencie));
        send_packet(Packet(PacketType::HEARTBEAT, 0, serverPeer)); // Set destination as the server serverPeer
    }
}

void ClientManager::toggleDebug()
{
    bool oldState = debugEnabled;
    debugEnabled = !debugEnabled;
    network_print(("Debug mode from " + std::string(oldState ? "Enabled" : "Disabled") +
                   " to " + std::string(debugEnabled ? "Enabled" : "Disabled") + "\n")
                      .c_str());
}

void ClientManager::TaskStopHeartbeat()
{
    if (!HeartBeatRunningFlag)
    {
        std::cout << "Heartbeat was not running. Why would you stop it?\n";
        return;
    }
    HeartBeatRunningFlag = false;

    if (ThreadHeartbeat.joinable())
        ThreadHeartbeat.join();
}

void ClientManager::connect(const std::string &serverAddress, uint16_t port)
{
    std::cout << std::endl;
    std::cout << "╭───────────────────────────────────────╮" << std::endl;
    std::cout << "│          Starting Tetris Client       │" << std::endl;
    std::cout << "├───────────────────────────────────────┤" << std::endl;
    std::cout << "│   Using NetworkManager version v" << NetworkManager::version << "     │" << std::endl;
    std::cout << "│   Connection target: " << serverAddress << ":" << port << "  │" << std::endl;
    std::cout << "╰───────────────────────────────────────╯" << std::endl;
    std::cout << std::endl;

    host = enet_host_create(nullptr, 1, 2, 0, 0); // 1 client, 2 channels

    try
    {
        if (!host)
            throw std::runtime_error("Failed to create ENet client host.");
    }
    catch (const std::exception &ex)
    {
        std::cerr << "Error: " << ex.what() << std::endl;
        return;
    }

    ENetAddress address;
    enet_address_set_host(&address, serverAddress.c_str());
    address.port = port;

    serverPeer = enet_host_connect(host, &address, 2, 0);

    try
    {
        if (!serverPeer)
            throw std::runtime_error("No available serverPeers for initiating an ENet connection.");
    }
    catch (const std::exception &ex)
    {
        std::cerr << "Error: " << ex.what() << std::endl;
        return;
    }

    TaskStartHeartbeat();
    TaskStartNetwork();
}

void ClientManager::disconnect()
{
    if (serverPeer)
    {
        enet_peer_disconnect_now(serverPeer, 0);
        enet_peer_reset(serverPeer);
    }

    TaskStopNetwork();
    TaskStopHeartbeat();
}

void ClientManager::on_receive_game_screen(const Packet &packet)
{
    try
    {
        nlohmann::json boardData = packet.toJson();
        std::lock_guard<std::mutex> lock(boardMutex);
        lastReceivedBoard = boardData;
        hasBoardData = true;
    }
    catch (const std::exception &e)
    {
        std::cerr << "Failed to parse game screen board JSON: " << e.what() << std::endl;
    }
}

nlohmann::json ClientManager::getLastBoardState()
{
    std::lock_guard<std::mutex> lock(boardMutex);
    return lastReceivedBoard;
}

// SE os quadros desincronizarem pode estar aqui o problema
bool ClientManager::boardDataAvailable()
{
    std::lock_guard<std::mutex> lock(boardMutex);
    if (hasBoardData)
    {
        hasBoardData = false;
        return true;
    }
    return false;
}

void ClientManager::request_game_start()
{
    send_packet(Packet(PacketType::REQUEST_START, 0, serverPeer));
}

void ClientManager::onPressKey(sf::Event::KeyEvent e)
{
    switch (e.code)
    {
    case sf::Keyboard::P:
        // if (debugEnabled) clientManager.network_print("Tecla P pressionada. Pausar o jogo.\n");
        send_packet(Packet(PacketType::PAUSE, 0, serverPeer));
        break;

    case sf::Keyboard::R:
        if (debugEnabled)
            network_print("Tecla R pressionada. Reiniciar o jogo.\n");
        send_packet(Packet(PacketType::RESTART, 0, serverPeer));
        break;
    case sf::Keyboard::Up:
        if (debugEnabled)
            network_print("Tecla Cima (Up) pressionada.\n");
        send_packet(Packet(PacketType::ROTATE_RIGHT, 0, serverPeer));
        break;

    case sf::Keyboard::Down:
        if (debugEnabled)
            network_print("Tecla Baixo (Down) pressionada.\n");
        send_packet(Packet(PacketType::ROTATE_LEFT, 0, serverPeer));
        break;

    case sf::Keyboard::Left:
        if (debugEnabled)
            network_print("Tecla Esquerda (Left) pressionada.\n");
        send_packet(Packet(PacketType::LEFT, 0, serverPeer));
        break;

    case sf::Keyboard::Right:
        if (debugEnabled)
            network_print("Tecla Direita (Right) pressionada.\n");
        send_packet(Packet(PacketType::RIGHT, 0, serverPeer));
        break;

    case sf::Keyboard::Space:
        if (debugEnabled)
            network_print("Tecla Espaco (Space) pressionada.\n");
        send_packet(Packet(PacketType::DROP_FASTER, 0, serverPeer));
        break;

    case sf::Keyboard::W:
        if (debugEnabled)
            network_print("Tecla W pressionada.\n");
        send_packet(Packet(PacketType::ROTATE_LEFT, 0, serverPeer));
        break;

    case sf::Keyboard::A:
        if (debugEnabled)
            network_print("Tecla A pressionada.\n");
        send_packet(Packet(PacketType::LEFT, 0, serverPeer));
        break;

    case sf::Keyboard::S:
        if (debugEnabled)
            network_print("Tecla S pressionada.\n");
        send_packet(Packet(PacketType::ROTATE_RIGHT, 0, serverPeer));
        break;

    case sf::Keyboard::D:
        if (debugEnabled)
            network_print("Tecla D pressionada.\n");
        send_packet(Packet(PacketType::RIGHT, 0, serverPeer));
        break;

    case sf::Keyboard::Enter:
        if (debugEnabled)
            network_print("Tecla Espaco (Enter) pressionada.\n");
        send_packet(Packet(PacketType::DROP_FASTER, 0, serverPeer));
        break;

    case sf::Keyboard::G:
        toggleDebug();
        break;

    default:
        break;
    }
}


// File: ./src/client/TetrisClient.cpp
#include <iostream>
#include <enet/enet.h>

#include "TetrisCell.hpp"
#include "ClientManager.hpp"

#include "screens/WaitingConnectionScreen.hpp"
#include "screens/GameScreen.hpp"
#include "screens/MenuScreen.hpp"
#include "screens/LobbyScreen.hpp"
#include "screens/BoardScreen.hpp"

ScreenManager screenManager;
ClientManager client;

void heartbeat_listener(const Packet &packet)
{
    client.on_receive_heartbeat();
}

void onPlayerListPacket(const Packet &packet)
{
    client.on_receive_player_list(packet);
}

void onGameScreenPacket(const Packet &packet)
{
    client.on_receive_game_screen(packet);
}

void onGameStartPacket(const Packet &packet)
{
    screenManager.setActiveScreen("game");
}

int main()
{
    client.registerListener(PacketType::HEARTBEAT, heartbeat_listener);
    client.registerListener(PacketType::PLAYER_LIST, onPlayerListPacket);
    client.registerListener(PacketType::GAME_SCREEN, onGameScreenPacket);
    client.registerListener(PacketType::STARTING_GAME, onGameStartPacket);

    sf::RenderWindow window(sf::VideoMode(800, 480), "Multi-Threaded Screens");

    screenManager.addScreen("main-menu", std::make_unique<MenuScreen>(screenManager, client));
    screenManager.addScreen("lobby", std::make_unique<LobbyScreen>(client));
    screenManager.addScreen("waiting-connection", std::make_unique<WaitingConnectionScreen>(screenManager, client));
    screenManager.addScreen("game", std::make_unique<BoardScreen>(client));

    screenManager.setActiveScreen("main-menu");
    screenManager.startThread();

    sf::Clock clock;

    while (window.isOpen())
    {
        sf::Event event;

        float deltaTime = clock.restart().asSeconds();

        window.clear(sf::Color::Black);
        screenManager.render(window);
        window.display();

        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
                window.close();
            screenManager.handleEvent(event);
        }
    }

    client.disconnect();
    return 0;
}


