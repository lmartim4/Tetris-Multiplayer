// File: ./CMakeFiles/3.31.1/CompilerIdCXX/CMakeCXXCompilerId.cpp
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"
# if __SUNPRO_CC >= 0x5100
   /* __SUNPRO_CC = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# endif

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"
  /* __HP_aCC = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"
  /* __DECCXX_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)

#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
# define COMPILER_ID "XL"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(__clang__) && defined(__cray__)
# define COMPILER_ID "CrayClang"
# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TASKING__)
# define COMPILER_ID "Tasking"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)

#elif defined(__ORANGEC__)
# define COMPILER_ID "OrangeC"
# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__) && defined(__ti__)
# define COMPILER_ID "TIClang"
  # define COMPILER_VERSION_MAJOR DEC(__ti_major__)
  # define COMPILER_VERSION_MINOR DEC(__ti_minor__)
  # define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
# define COMPILER_VERSION_INTERNAL DEC(__ti_version__)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__) || defined(__GNUG__)
# define COMPILER_ID "GNU"
# if defined(__GNUC__)
#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# else
#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__clang__) && defined(__ti__)
# if defined(__ARM_ARCH)
#  define ARCHITECTURE_ID "Arm"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#elif defined(__TASKING__)

# if defined(__CTC__) || defined(__CPTC__)
#  define ARCHITECTURE_ID "TriCore"

# elif defined(__CMCS__)
#  define ARCHITECTURE_ID "MCS"

# elif defined(__CARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__CARC__)
#  define ARCHITECTURE_ID "ARC"

# elif defined(__C51__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__CPCP__)
#  define ARCHITECTURE_ID "PCP"

# else
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#define CXX_STD_98 199711L
#define CXX_STD_11 201103L
#define CXX_STD_14 201402L
#define CXX_STD_17 201703L
#define CXX_STD_20 202002L
#define CXX_STD_23 202302L

#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > CXX_STD_17
#    define CXX_STD _MSVC_LANG
#  elif _MSVC_LANG == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14 && __cplusplus > CXX_STD_17
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14
#    define CXX_STD CXX_STD_17
#  elif defined(__INTEL_CXX11_MODE__) && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  elif defined(__INTEL_CXX11_MODE__)
#    define CXX_STD CXX_STD_11
#  else
#    define CXX_STD CXX_STD_98
#  endif
#elif defined(_MSC_VER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > __cplusplus
#    define CXX_STD _MSVC_LANG
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__NVCOMPILER)
#  if __cplusplus == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__INTEL_COMPILER) || defined(__PGI)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_namespace_attributes)
#    define CXX_STD CXX_STD_17
#  elif __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif (defined(__IBMCPP__) || defined(__ibmxl__)) && defined(__linux__)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif __cplusplus == 1 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#  define CXX_STD CXX_STD_11
#else
#  define CXX_STD __cplusplus
#endif

const char* info_language_standard_default = "INFO" ":" "standard_default["
#if CXX_STD > CXX_STD_23
  "26"
#elif CXX_STD > CXX_STD_20
  "23"
#elif CXX_STD > CXX_STD_17
  "20"
#elif CXX_STD > CXX_STD_14
  "17"
#elif CXX_STD > CXX_STD_11
  "14"
#elif CXX_STD >= CXX_STD_11
  "11"
#else
  "98"
#endif
"]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__)) &&                                     \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#ifdef COMPILER_VERSION_INTERNAL
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}



// File: ./include/common/ISerializable.hpp
#pragma once
#include <json.hpp>
#include <string>

class ISerializable
{
public:
    virtual ~ISerializable() = default;
    virtual nlohmann::json serialize() const = 0;
    virtual void deserialize(const nlohmann::json &data) = 0;
};


// File: ./include/common/PlayerData.hpp
#pragma once
#include <string>
#include "ISerializable.hpp"
#include "json.hpp"

struct PlayerData : public ISerializable
{
    int playerID = -1;
    std::string playerName;
    int score = 0;
    bool isConnected = false;

    nlohmann::json serialize() const override
    {
        return {
            {"playerID", playerID},
            {"playerName", playerName},
            {"score", score},
            {"isConnected", isConnected}};
    }

    void deserialize(const nlohmann::json &data) override
    {
        playerID = data.at("playerID").get<int>();
        playerName = data.at("playerName").get<std::string>();
        score = data.at("score").get<int>();
        isConnected = data.at("isConnected").get<bool>();
    }
};



// File: ./include/common/PacketType.hpp
#pragma once

enum class PacketType : char
{
    // Game actions/commands Packets
    JOIN_REQUEST,
    JOIN_ACCEPTED,
    JOIN_DENIED,
    START,
    RESTART,
    PAUSE,
    RESUME,
    LEFT,
    RIGHT,
    ROTATE_LEFT,
    ROTATE_RIGHT,
    DROP_FASTER,
    DROP_INSTANT,

    // Network/connection-related
    HEARTBEAT,  // A heartbeat packet to keep the connection alive
    CONNECT,    // A packet sent upon connecting
    DISCONNECT, // A packet sent upon disconnection

    PLAYER_LIST,

    // Error packet threating
    PARSING_ERROR // Reserved for any custom packet types
};

// Utility function to convert PacketType to a string (for debugging)
inline const char *PacketTypeToString(PacketType type)
{
    switch (type)
    {
    case PacketType::JOIN_REQUEST:
        return "JOIN_REQUEST";
    case PacketType::JOIN_ACCEPTED:
        return "JOIN_ACCEPTED";
    case PacketType::JOIN_DENIED:
        return "JOIN_DENIED";
    case PacketType::START:
        return "START";
    case PacketType::RESTART:
        return "RESTART";
    case PacketType::PAUSE:
        return "PAUSE";
    case PacketType::RESUME:
        return "RESUME";
    case PacketType::LEFT:
        return "LEFT";
    case PacketType::RIGHT:
        return "RIGHT";
    case PacketType::ROTATE_LEFT:
        return "ROTATE_LEFT";
    case PacketType::ROTATE_RIGHT:
        return "ROTATE_RIGHT";
    case PacketType::DROP_FASTER:
        return "DROP_FASTER";
    case PacketType::DROP_INSTANT:
        return "DROP_INSTANT";
    case PacketType::HEARTBEAT:
        return "HEARTBEAT";
    case PacketType::CONNECT:
        return "CONNECT";
    case PacketType::DISCONNECT:
        return "DISCONNECT";
    case PacketType::PARSING_ERROR:
        return "PARSING_ERROR";
    default:
        return "UNKNOWN_PACKET_TYPE";
    }
}


// File: ./include/common/NetworkManager.hpp
#pragma once

#include "PacketType.hpp"
#include <json.hpp>

#include <enet/enet.h>
#include <queue>
#include <vector>
#include <atomic>
#include <unordered_map>
#include <functional>
#include <thread>
#include <memory>

// This struct represents a network packet. It contains information such as the packet type,
// data payload, and the peer to which the packet is being sent or received from.
struct Packet
{
    PacketType type;           // The type of the packet (ACTION, HEARTBEAT, etc.)
    std::vector<uint8_t> data; // Data payload of the packet
    ENetPeer *peer;            // The peer that the packet is being sent to or received from

    // Constructor to initialize a packet with its type, data, and optional destination peer.
    Packet(PacketType t, const std::vector<uint8_t> &d, ENetPeer *dest = nullptr)
        : type(t), data(d), peer(dest) {}

    // New constructor that accepts a JSON object
    Packet(PacketType t, const nlohmann::json &j, ENetPeer *dest = nullptr)
        : type(t), peer(dest)
    {
        // Convert JSON to string
        std::string jsonStr = j.dump();
        // Store as bytes
        data.assign(jsonStr.begin(), jsonStr.end());
    }

    // Serialize the packet to raw byte data so it can be sent over the network.
    std::vector<uint8_t> toRawData() const
    {
        std::vector<uint8_t> rawData;
        rawData.push_back(static_cast<uint8_t>(type));           // First byte stores the packet type
        rawData.insert(rawData.end(), data.begin(), data.end()); // Append the rest of the data
        return rawData;
    }

    // Helper method to parse the data vector into a JSON object
    nlohmann::json toJson() const
    {
        std::string jsonStr(data.begin(), data.end());
        return nlohmann::json::parse(jsonStr);
    }
};

// The NetworkManager class is responsible for managing all network communication.
// It sets up the network host, handles incoming and outgoing packets, and provides
// methods to register listeners for specific packet types.
class NetworkManager
{
public:
    NetworkManager();          // Constructor: Initializes the ENet library and network manager.
    virtual ~NetworkManager(); // Destructor: Cleans up network resources and stops the network loop.

    static const int version = 1; // NetworkManager version for debugging purposes

    // Registers a listener function for a specific packet type.
    // The listener will be called whenever a packet of the given type is received.
    void registerListener(PacketType packetType, std::function<void(const Packet &)> callback);

    // Adds a packet to the outgoing packet queue to be sent to its destination peer.
    void send_packet(const Packet &packet);

    // Checks whether the network task (event loop) is currently running.
    bool isRunning() const;

    // Utility function to convert a 32-bit integer IP address to an IPv4 string (e.g., "192.168.1.1").
    static char *uint32_to_ipv4(uint32_t ip_addr);

    // Prints a message with a timestamp to the console for debugging purposes.
    static void network_print(const char *array);

    // Returns the ENetHost object, which represents either the client or server in ENet.
    ENetHost *getHost();
    
    std::vector<ENetPeer *> getPeers();

protected:
    ENetHost *host = nullptr; // ENet host, which can either be a server or a client.

    // Converts an ENet packet into a custom Packet structure by extracting the packet type and data.
    static Packet parsePacket(const ENetPacket *enetPacket, ENetPeer *sourcePeer);

    // Handles a received packet by calling the registered listener for its packet type.
    void handlePacket(Packet &packet, ENetPeer *peer);

    // Abstract method to handle when a peer connects to the host. Implemented by subclasses.
    virtual void onPeerConnect(ENetPeer *peer) = 0;

    // Abstract method to handle when a peer disconnects from the host. Implemented by subclasses.
    virtual void onPeerDisconnect(ENetPeer *peer) = 0;

    // Starts the network event loop in a separate thread to process incoming and outgoing packets.
    void TaskStartNetwork();

    // Stops the network loop and cleans up resources related to networking.
    void TaskStopNetwork();

private:
    std::thread networkThread;         // Thread for running the network event loop.
    std::atomic<bool> running = false; // Atomic flag to indicate whether the network loop is active.

    // Queue for outgoing packets that need to be sent to peers.
    std::queue<Packet> outgoingPackets;

    // Queue for incoming packets that have been received but not yet processed.
    std::queue<Packet> incommingPackets;

    // A map that associates packet types (as uint8_t) with their corresponding listener functions.
    std::unordered_map<uint8_t, std::function<void(const Packet &)>> listeners;

    // Processes events received from ENet, such as peer connections, disconnections, and packet receptions.
    void processENetEvent(ENetEvent &event);

    // Processes any incoming packets in the queue and triggers the appropriate listeners.
    void processIncomingPackets();

    // Sends any outgoing packets in the queue to their destination peers or broadcasts them to all peers.
    void sendOutgoingPackets();

    // Creates an ENet packet from a custom Packet structure, ready to be sent over the network.
    ENetPacket *createENetPacket(const Packet &packet);

    // The main network loop that continuously processes ENet events, sends outgoing packets, and handles incoming ones.
    void TaskNetwork();
};



// File: ./include/common/TetrisActions.hpp
#pragma once
enum class TetrisAction {
    START,
    RESTART,
    PAUSE,
    RESUME,
    LEFT,
    RIGHT,
    ROTATE_LEFT,
    ROTATE_RIGHT,
    DROP_FASTER,
    DROP_INSTANT
};

inline const char* TetrisActionToString(TetrisAction action) {
    switch (action) {
    case TetrisAction::START: return "START";
    case TetrisAction::RESTART: return "RESTART";
    case TetrisAction::PAUSE: return "PAUSE";
    case TetrisAction::RESUME: return "RESUME";
    case TetrisAction::LEFT: return "LEFT";
    case TetrisAction::RIGHT: return "RIGHT";
    case TetrisAction::ROTATE_LEFT: return "ROTATE_LEFT";
    case TetrisAction::ROTATE_RIGHT: return "ROTATE_RIGHT";
    case TetrisAction::DROP_FASTER: return "DROP_FASTER";
    case TetrisAction::DROP_INSTANT: return "DROP_INSTANT";
    default: return "UNKNOWN_ACTION";
    }
}


// File: ./include/server/Player.hpp
#pragma once
#include "PlayerData.hpp"
#include <iostream>

class Player
{
public:
    // Construct a player with a given ID and name.
    // The server sets initial states such as score = 0 and isConnected = true when they join.
    Player(int id, const std::string &name)
    {
        data.playerID = id;
        data.playerName = name;
        data.score = 0;
        data.isConnected = true;
    }

    ~Player()
    {
        std::cout << "Player " << data.playerID << " was deleted " << std::endl;
    }

    // Access the player's read-only data.
    const PlayerData getData() const
    {
        return data;
    }

    // Modify player attributes. These methods are only run on the server,
    // ensuring the server remains the authority.
    void addScore(int amount)
    {
        data.score += amount;
        // The server can then notify all clients about the updated score
    }

    void setName(const std::string &newName)
    {
        data.playerName = newName;
        // Possibly broadcast name change to clients
    }

    void disconnect()
    {
        data.isConnected = false;
        // Handle cleanup, notify clients, etc.
    }

    bool isConnected() const
    {
        return data.isConnected;
    }

private:
    PlayerData data;
};



// File: ./include/server/ServerManager.hpp
#pragma once

#include <enet/enet.h>
#include <thread>
#include <map>

#include "NetworkManager.hpp"
#include "Player.hpp"

class ServerManager : public NetworkManager
{
private:
    int getNextAvailablePlayerID();
    void broadcastPlayerList();
    void createPlayerAndLink(ENetPeer *  peer);

protected:
    void onPeerConnect(ENetPeer *  peer) override;
    void onPeerDisconnect(ENetPeer *  peer) override;

public:
    ServerManager(uint16_t port = 12345);
    ~ServerManager() {};
};



// File: ./include/client/TetrisCell.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <functional>

class TetrisCell
{
    sf::RectangleShape cellShape;
    std::function<void()> onClickCallback;

public:
    TetrisCell(sf::Vector2f size, sf::Vector2f position, sf::Color color)
    {
        cellShape.setSize(size);
        cellShape.setPosition(position);
        cellShape.setFillColor(color);
        cellShape.setOutlineThickness(1.0f);
        cellShape.setOutlineColor(sf::Color::Black);
    }

    void setOnClick(const std::function<void()> &callback) { onClickCallback = callback; }

    void handleEvent(const sf::Event &event)
    {
        if (event.type == sf::Event::MouseButtonPressed)
            if (cellShape.getGlobalBounds().contains(static_cast<float>(event.mouseButton.x), static_cast<float>(event.mouseButton.y)))
                if (onClickCallback)
                    onClickCallback();
    }

    void render(sf::RenderWindow &window) { window.draw(cellShape); }

    void setColor(const sf::Color &color) { cellShape.setFillColor(color); }

    sf::RectangleShape &getShape() { return cellShape; }
};



// File: ./include/client/screens/GameScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>
#include <map>

#include "Screen.hpp"

// Game Screen
class GameScreen : public Screen
{
    sf::Text gameText;

public:
    GameScreen()
    {
        gameText.setFont(defaultFont);
        gameText.setString("Game Screen");
        gameText.setCharacterSize(40);
        gameText.setFillColor(sf::Color::Green);
        gameText.setPosition(200, 200);
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        // Handle game events
        if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape)
        {
            std::cout << "Game event: escape pressed" << std::endl;
        }
    }

    void update(float deltaTime) override
    {
        // Game update logic
        if (!running)
            return;
        // Simulate some work
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }

    void render(sf::RenderWindow &window) override
    {
        window.draw(gameText);
    }
};


// File: ./include/client/screens/LobbyScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <memory>
#include "Screen.hpp"

class LobbyScreen : public Screen
{
    sf::Text lobbyText;
    std::vector<sf::CircleShape> playerCircles;
    std::map<int, std::string> players; // Map of player IDs and their names (or other details)
    const float circleRadius = 30.0f;   // Radius of each player circle
    const float padding = 10.0f;        // Padding between circles

public:
    LobbyScreen()
    {
        // Set lobby header text
        lobbyText.setFont(defaultFont);
        lobbyText.setString("Lobby Screen");
        lobbyText.setCharacterSize(40);
        lobbyText.setFillColor(sf::Color::Blue);
        lobbyText.setPosition(230, 20);
    }

    // Function to add a new player
    void addPlayer(int playerId, const std::string &playerName)
    {
        players[playerId] = playerName;

        sf::CircleShape circle(circleRadius);
        circle.setFillColor(sf::Color::Cyan);
        circle.setOutlineThickness(2.0f);
        circle.setOutlineColor(sf::Color::Black);

        // Calculate position based on the current number of players
        int index = playerCircles.size();
        float x = (index % 5) * (2 * circleRadius + padding) + 100; // Adjust columns
        float y = (index / 5) * (2 * circleRadius + padding) + 100; // Adjust rows

        circle.setPosition(x, y);
        playerCircles.push_back(circle);
    }

    // Function to remove a player
    void removePlayer(int playerId)
    {
        if (players.erase(playerId) > 0)
        {
            playerCircles.clear();
            int index = 0;
            for (const auto &[id, name] : players)
            {
                sf::CircleShape circle(circleRadius);
                circle.setFillColor(sf::Color::Cyan);
                circle.setOutlineThickness(2.0f);
                circle.setOutlineColor(sf::Color::Black);

                float x = (index % 5) * (2 * circleRadius + padding) + 100;
                float y = (index / 5) * (2 * circleRadius + padding) + 100;

                circle.setPosition(x, y);
                playerCircles.push_back(circle);
                ++index;
            }
        }
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        // Example: Handle "Escape" key to leave the lobby
        if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape)
        {
            std::cout << "Lobby event: escape pressed" << std::endl;
        }
    }

    void update(float deltaTime) override
    {
        // Update logic for lobby screen (e.g., fetching player list from server)
    }

    void render(sf::RenderWindow &window) override
    {
        // Draw the lobby text
        window.draw(lobbyText);

        // Draw all player circles
        for (auto &circle : playerCircles)
        {
            window.draw(circle);
        }
    }
};



// File: ./include/client/screens/MenuScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>
#include <map>

#include "Screen.hpp"
#include "InteractiveText.hpp"
#include "ClientManager.hpp"

class MenuScreen : public Screen
{
    InteractiveText titleText;
    InteractiveText connectText;
    InteractiveText quitText;
    ScreenManager &manager; // Reference to ScreenManager
    ClientManager &clientMan;
#define x_offset_screen 80
#define y_offset_screen 80

public:
    MenuScreen(ScreenManager &screenManager, ClientManager &clientManager)
        : titleText(defaultFont, "Main Menu", 40, sf::Color::White, {x_offset_screen + 200, y_offset_screen + 50}),
          connectText(defaultFont, "Connect", 30, sf::Color::White, {x_offset_screen + 300, y_offset_screen + 200}),
          quitText(defaultFont, "Quit", 30, sf::Color::White, {x_offset_screen + 200, y_offset_screen + 200}),
          manager(screenManager), clientMan(clientManager)
    {
        connectText.setOnClick([this]()
                               {
                                std::cout << "Trying to connect\n";
                                manager.setActiveScreen("waiting-connection");
                                clientMan.connect(); });

        quitText.setOnClick([this]()
                            {
                                std::cout << "Quit button clicked!\n";
                                // manager.quit(); // Example: add a quit method to ScreenManager
                            });
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        connectText.handleEvent(event);
        quitText.handleEvent(event);
    }

    void update(float deltaTime) override
    {
        // Menu update logic
    }

    void render(sf::RenderWindow &window) override
    {
        titleText.render(window);
        connectText.render(window);
        quitText.render(window);
    }
};



// File: ./include/client/screens/WaitingConnectionScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>
#include <map>

#include "Screen.hpp"
#include "InteractiveText.hpp"
#include "ClientManager.hpp"

class WaitingConnectionScreen : public Screen
{
    InteractiveText titleText;
    InteractiveText backText;

    ScreenManager &screenMan;
    ClientManager &clientMan;

#define x_offset_screen 80
#define y_offset_screen 80

public:
    WaitingConnectionScreen(ScreenManager &screenManager, ClientManager &clientManager)
        : titleText(defaultFont, "Waiting for server...", 40, sf::Color::White, {x_offset_screen + 200, y_offset_screen + 50}),
          backText(defaultFont, "Back", 30, sf::Color::White, {x_offset_screen + 300, y_offset_screen + 200}),
          screenMan(screenManager), clientMan(clientManager)
    {
        backText.setOnClick([this]()
                            {
                                std::cout << "Getting back to main screen\n";
                                clientMan.disconnect();
                                screenMan.setActiveScreen("main-menu"); });
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        backText.handleEvent(event);
    }

    void update(float deltaTime) override
    {
        if (clientMan.IsConnected())
        {
            screenMan.setActiveScreen("lobby");
        }
    }

    void render(sf::RenderWindow &window) override
    {
        titleText.render(window);
        backText.render(window);
    }
};



// File: ./include/client/screens/InteractiveText.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <functional>

class InteractiveText
{
    sf::Text text;
    std::function<void()> onClickCallback;

public:
    InteractiveText(const sf::Font &font, const std::string &str, unsigned int charSize, sf::Color color, sf::Vector2f position)
    {
        text.setFont(font);
        text.setString(str);
        text.setCharacterSize(charSize);
        text.setFillColor(color);
        text.setPosition(position);
    }

    void setOnClick(const std::function<void()> &callback) { onClickCallback = callback; }

    void handleEvent(const sf::Event &event)
    {
        if (event.type == sf::Event::MouseButtonPressed)
            if (text.getGlobalBounds().contains(static_cast<float>(event.mouseButton.x), static_cast<float>(event.mouseButton.y)))
                if (onClickCallback)
                    onClickCallback();
    }

    void render(sf::RenderWindow &window) { window.draw(text); }

    sf::Text &getText() { return text; }
};



// File: ./include/client/screens/Screen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>
#include <map>

// Base class for screens
class Screen {
public:
    Screen(){
        // Load font
        if (!defaultFont.loadFromFile("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf"))
        {
            std::cerr << "Error loading font!" << std::endl;
        }
    }
    virtual ~Screen() {}
    virtual void handleEvent(sf::Event event, class ScreenManager& manager) = 0;
    virtual void update(float deltaTime) = 0;
    virtual void render(sf::RenderWindow& window) = 0;

    void stop() {
        running = false;
    }

protected:
    std::atomic<bool> running{ true };
    sf::Font defaultFont;
};

// Screen Manager
class ScreenManager {
    std::map<std::string, std::unique_ptr<Screen>> screens;
    Screen* activeScreen = nullptr;

    std::thread screenThread;
    std::mutex mtx;
    std::condition_variable cv;

    std::atomic<bool> threadRunning{ false };

public:
    ~ScreenManager() {
        stopThread();
    }

    void quit() {
        // Logic to terminate the application
        std::cout << "Application quitting...\n";
        stopThread();
        exit(0);
    }

    void addScreen(const std::string& name, std::unique_ptr<Screen> screen) {
        screens[name] = std::move(screen);
    }

    void setActiveScreen(const std::string& name) {
        {
            std::lock_guard<std::mutex> lock(mtx);
            activeScreen = screens[name].get();
        }
        cv.notify_one();
    }

    void handleEvent(sf::Event event) {
        if (activeScreen) {
            activeScreen->handleEvent(event, *this);
        }
    }

    void update(float deltaTime) {
        if (activeScreen) {
            activeScreen->update(deltaTime);
        }
    }

    void render(sf::RenderWindow& window) {
        if (activeScreen) {
            activeScreen->render(window);
        }
    }

    void startThread() {
        threadRunning = true;
        screenThread = std::thread([this]() {
            while (threadRunning) {
                std::unique_lock<std::mutex> lock(mtx);
                cv.wait(lock, [this]() { return activeScreen != nullptr; });
                lock.unlock();

                while (threadRunning) {
                    if (activeScreen) {
                        activeScreen->update(0.016f); // Simulate ~60 FPS updates
                    }
                    std::this_thread::sleep_for(std::chrono::milliseconds(16));
                }
            } });
    }

    void stopThread() {
        threadRunning = false;
        if (screenThread.joinable()) {
            screenThread.join();
        }
    }
};


// File: ./include/client/screens/BoardScreen.hpp
#pragma once

#include <SFML/Graphics.hpp>
#include <vector>
#include <memory>
#include <string>
#include "Screen.hpp"
#include "TetrisCell.hpp"

constexpr int BOARD_WIDTH = 10;
constexpr int BOARD_HEIGHT = 10;
constexpr int CELL_SIZE = 40;

class BoardScreen : public Screen
{
    std::vector<std::vector<std::shared_ptr<TetrisCell>>> grid;

public:
    BoardScreen()
    {
        for (int y = 0; y < BOARD_HEIGHT; ++y)
        {
            std::vector<std::shared_ptr<TetrisCell>> row;
            for (int x = 0; x < BOARD_WIDTH; ++x)
            {
                auto cell = std::make_shared<TetrisCell>(
                    sf::Vector2f(CELL_SIZE, CELL_SIZE),
                    sf::Vector2f(x * CELL_SIZE, y * CELL_SIZE),
                    sf::Color::Red // Default color
                );

                row.push_back(cell);
            }
            grid.push_back(row);
        }
    }

    void handleEvent(sf::Event event, ScreenManager &manager) override
    {
        for (auto &row : grid)
            for (auto &cell : row)
                cell->handleEvent(event);
    }

    void update(float deltaTime) override {}

    void render(sf::RenderWindow &window) override
    {
        for (auto &row : grid)
            for (auto &cell : row)
                cell->render(window);
    }
};



// File: ./include/client/ClientManager.hpp
#pragma once

#include "NetworkManager.hpp"
#include <SFML/Graphics.hpp>
#include <thread>
#include <atomic>

class ClientManager : public NetworkManager
{
private:
    ENetPeer *serverPeer;

    std::atomic<bool> isConnected = false;

    std::thread ThreadHeartbeat;
    unsigned long last_heartbeat;

    bool debugEnabled = false;
    void handleKeyPress(sf::Event keyEvent, sf::RenderWindow &window);

protected:
    void onPeerConnect(ENetPeer *peer) override;
    void onPeerDisconnect(ENetPeer *peer) override;

public:
    ClientManager();
    ~ClientManager();

    void toggleDebug();
    void on_receive_heartbeat();

    void TaskStartHeartbeat();
    void TaskHeartbeat();
    void TaskStopHeartbeat();

    void connect(const std::string &serverAddress = "localhost", uint16_t port = 12345);
    void disconnect();

    bool IsConnected() const { return isConnected; };
};


// File: ./src/common/NetworkManager.cpp
#include "NetworkManager.hpp"
#include <iomanip>
#include <iostream>
#include <thread>

char *NetworkManager::uint32_to_ipv4(uint32_t ip_addr)
{
    // Allocate memory for the resulting IP address string (e.g., "255.255.255.255\0" is 16 characters)
    static char ip_str[16];

    // Convert from host byte order to network byte order
    ip_addr = htonl(ip_addr);

    // Break the integer into its four bytes and format as an IPv4 address string
    snprintf(ip_str, sizeof(ip_str), "%u.%u.%u.%u",
             (ip_addr >> 24) & 0xFF,
             (ip_addr >> 16) & 0xFF,
             (ip_addr >> 8) & 0xFF,
             ip_addr & 0xFF);

    return ip_str;
}
NetworkManager::NetworkManager()
{
    if (enet_initialize() != 0)
    {
        std::cerr << "Failed to initialize ENET!" << std::endl;
        throw std::runtime_error("Failed to initialize ENet.");
    }
}

NetworkManager::~NetworkManager()
{
    TaskStopNetwork();
}

void NetworkManager::send_packet(const Packet &packet)
{
    outgoingPackets.push(packet);
}

void NetworkManager::network_print(const char *array)
{
    // Get current time as time_t (seconds since epoch)
    auto now = std::chrono::system_clock::now();
    std::time_t currentTime = std::chrono::system_clock::to_time_t(now);

    // Convert time_t to local time (struct tm)
    std::tm *localTime = std::localtime(&currentTime);
    std::cout << "[" << std::put_time(localTime, "%H:%M:%S") << "] " << array;
}

void NetworkManager::TaskStartNetwork()
{
    if (running)
    {
        std::cout << "Error: Network Task already running! (Why would you start again?)" << std::endl;
        return;
    }

    network_print("Initializing Network Task...\n");
    running = true;
    networkThread = std::thread(&NetworkManager::TaskNetwork, this);
}

void NetworkManager::registerListener(PacketType packetType, std::function<void(const Packet &)> callback)
{
    listeners[static_cast<uint8_t>(packetType)] = callback;
}

void NetworkManager::handlePacket(Packet &packet, ENetPeer *peer)
{
    uint8_t packetType = static_cast<uint8_t>(packet.type);
    if (listeners.find(packetType) != listeners.end())
    {
        packet.peer = peer;
        listeners[packetType](packet); // Pass both packet and the source peer
    }
    else
    {
        network_print("");
        std::cout << "[" << uint32_to_ipv4(peer->address.host) << ":" << peer->address.port << "]" << " >> \"" << PacketTypeToString(packet.type) << "\" (No listener registred)\n";
    }
}

void NetworkManager::processIncomingPackets()
{
    while (!incommingPackets.empty())
    {
        Packet packet = incommingPackets.front();
        incommingPackets.pop();
        handlePacket(packet, packet.peer);
    }
}

void NetworkManager::TaskStopNetwork()
{
    running = false;

    enet_host_destroy(host);
    if (networkThread.joinable())
        networkThread.join();
}

bool NetworkManager::isRunning() const
{
    return running;
}

Packet NetworkManager::parsePacket(const ENetPacket *enetPacket, ENetPeer *sourcePeer)
{
    if (enetPacket->dataLength < 1)
    {
        network_print("Failed to parse a packet from ");
        std::cout << uint32_to_ipv4(sourcePeer->address.host) << ":" << sourcePeer->address.port << std::endl;

        return Packet(PacketType::PARSING_ERROR, 0, sourcePeer);
    }
    PacketType type = static_cast<PacketType>(enetPacket->data[0]);                             // First byte is the packet type
    std::vector<uint8_t> data(enetPacket->data + 1, enetPacket->data + enetPacket->dataLength); // Remaining data
    return Packet(type, data, sourcePeer);
}

ENetPacket *NetworkManager::createENetPacket(const Packet &packet)
{
    std::vector<uint8_t> rawData = packet.toRawData();
    return enet_packet_create(rawData.data(), rawData.size(), ENET_PACKET_FLAG_RELIABLE);
}

void NetworkManager::TaskNetwork()
{
    int network_frequencie = 20; // Hertz
    while (running)
    {
        ENetEvent event;

        while (enet_host_service(host, &event, (1000 / network_frequencie)) > 0)
            processENetEvent(event);

        sendOutgoingPackets();
        processIncomingPackets();
    }
}

void NetworkManager::sendOutgoingPackets()
{
    while (!outgoingPackets.empty())
    {
        Packet packet = outgoingPackets.front();
        outgoingPackets.pop();

        if (packet.peer)
        {
            ENetPacket *enetPacket = createENetPacket(packet);
            enet_peer_send(packet.peer, 0, enetPacket);
        }
        else
        {
            std::vector<uint8_t> rawData = packet.toRawData();
            for (size_t i = 0; i < host->peerCount; ++i)
            {
                ENetPacket *enetPacket = enet_packet_create(rawData.data(), rawData.size(), ENET_PACKET_FLAG_RELIABLE);
                enet_peer_send(&host->peers[i], 0, enetPacket);
            }
        }
    }
}

void NetworkManager::processENetEvent(ENetEvent &event)
{
    switch (event.type)
    {
    case ENET_EVENT_TYPE_CONNECT:
    {
        onPeerConnect(event.peer);
        break;
    }

    case ENET_EVENT_TYPE_RECEIVE:
    {
        Packet packet = parsePacket(event.packet, event.peer);
        handlePacket(packet, event.peer);
        enet_packet_destroy(event.packet);
    }
    break;

    case ENET_EVENT_TYPE_DISCONNECT:
    {
        onPeerDisconnect(event.peer);
        break;
    }
    default:
    {
        std::cout << "[ENET] EventType = " << event.type << std::endl;
        break;
    }
    }
}

ENetHost *NetworkManager::getHost() { return host; }

std::vector<ENetPeer *> NetworkManager::getPeers()
{
    std::vector<ENetPeer *> peers;
    if (!host)
        return peers; // If host is not initialized, just return empty.

    for (size_t i = 0; i < host->peerCount; ++i)
    {
        ENetPeer &p = host->peers[i];
        // Only consider peers that are fully connected
        if (p.state == ENET_PEER_STATE_CONNECTED)
        {
            peers.push_back(&p);
        }
    }
    return peers; // Return by value, so the caller gets a valid copy.
}



// File: ./src/server/TetrisServer.cpp
#include <enet/enet.h>
#include <iostream>
#include "ServerManager.hpp"

ServerManager server(12345);

void HeartbeatListener(const Packet &packet)
{
    server.send_packet(packet);
}

void JoinRequestListener(const Packet &packet)
{
    if (server.getHost()->connectedPeers < 4)
        server.send_packet(Packet(PacketType::JOIN_ACCEPTED, 0, packet.peer));
    else
        server.send_packet(Packet(PacketType::JOIN_DENIED, 0, packet.peer));
}

int main(int argc, const char *argv[])
{
    if (server.isRunning())
        server.network_print("Waiting connections...\n");
    else
        return -1;

    server.registerListener(PacketType::JOIN_REQUEST, JoinRequestListener);
    server.registerListener(PacketType::HEARTBEAT, HeartbeatListener);

    while (server.isRunning())
        std::this_thread::sleep_for(std::chrono::milliseconds(10));

    return 0;
}



// File: ./src/server/ServerManager.cpp
#include "ServerManager.hpp"
#include <iostream>
#include <stdexcept>

#define MAX_CLIENTS 32
#define CHANNELS 2

void ServerManager::onPeerConnect(ENetPeer * peer)
{
    network_print("");
    std::cout << "[CONNECTED] " << uint32_to_ipv4(peer->address.host) << ":" << peer->address.port << std::endl;

    createPlayerAndLink(peer);
    broadcastPlayerList();
}
void ServerManager::onPeerDisconnect(ENetPeer * peer)
{
    network_print("");
    std::cout << "[DISCONNECTED] " << uint32_to_ipv4(peer->address.host) << ":" << peer->address.port << std::endl;
    delete (Player *)peer->data;
}

ServerManager::ServerManager(uint16_t port)
{
    std::cout << std::endl;
    std::cout << "" << std::endl;
    std::cout << "          Starting Tetris Server       " << std::endl;
    std::cout << "" << std::endl;
    std::cout << "   Using NetworkManager version v" << NetworkManager::version << "     " << std::endl;
    std::cout << "   Opening server at port " << port << "        " << std::endl;
    std::cout << "" << std::endl;
    std::cout << std::endl;

    ENetAddress address;
    enet_address_set_host(&address, "0.0.0.0");
    address.port = port;

    try
    {
        host = enet_host_create(&address, MAX_CLIENTS, CHANNELS, 0, 0);
        if (!host)
            throw std::runtime_error("Failed to create ENet server host. Is it already running? (Port busy)");
    }
    catch (const std::exception &ex)
    {
        std::cerr << "Error: " << ex.what() << std::endl;
        return;
    }

    TaskStartNetwork();
}

int ServerManager::getNextAvailablePlayerID()
{
    static int currentID = 0;
    return currentID++;
}

void ServerManager::createPlayerAndLink(ENetPeer * peer)
{
    Player *newPlayer = new Player(getNextAvailablePlayerID(), "Unnamed");
    peer->data = (void *)newPlayer;
    std::cout << "New client connected. Assigned PlayerID: " << newPlayer->getData().playerID << "\n";
}

void ServerManager::broadcastPlayerList()
{
    nlohmann::json message = nlohmann::json::array();

    for (ENetPeer * entry : getPeers())
    {
        if (!entry->data)
        {
            // This peer doesn't have a Player associated yet, skip it
            std::cout << "~No player~" << std::endl;
            continue;
        }
        Player *player = (Player *)entry->data;

        nlohmann::json playerJson = player->getData().serialize();

        message.push_back(nlohmann::json::array({player->getData().playerID, playerJson}));
    }
    // send_packet(Packet(PacketType::PLAYER_LIST, message, nullptr));
}


// File: ./src/client/ClientManager.cpp
#include "ClientManager.hpp"
#include <iostream>
#include <chrono>
#include <SFML/Graphics.hpp>

ClientManager::ClientManager() {}
ClientManager::~ClientManager() {}

void ClientManager::onPeerConnect(ENetPeer * peer)
{
    isConnected = true;
    std::cout << std::endl;
    network_print("");
    std::cout << "Connection successful to " << uint32_to_ipv4(peer->address.host) << ":" << peer->address.port << std::endl
              << std::endl;
}
void ClientManager::onPeerDisconnect(ENetPeer * peer)
{
    isConnected = false;
    network_print("Disconnected from server\n");
}

void ClientManager::on_receive_heartbeat()
{
    auto now = std::chrono::system_clock::now();
    auto now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    last_heartbeat = now_ms;
}

void ClientManager::TaskStartHeartbeat()
{
    network_print("Initializing Heartbeat Task...\n");
    ThreadHeartbeat = std::thread(&ClientManager::TaskHeartbeat, this);
}

void ClientManager::TaskHeartbeat()
{
    int heartbeat_frequencie = 1; // Hertz
    while (isRunning())
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000 / heartbeat_frequencie));
        send_packet(Packet(PacketType::HEARTBEAT, 0, serverPeer)); // Set destination as the server serverPeer
    }
}

void ClientManager::toggleDebug()
{
    bool oldState = debugEnabled;
    debugEnabled = !debugEnabled;
    network_print(("Debug mode from " + std::string(oldState ? "Enabled" : "Disabled") +
                   " to " + std::string(debugEnabled ? "Enabled" : "Disabled") + "\n")
                      .c_str());
}

void ClientManager::TaskStopHeartbeat()
{
    if (ThreadHeartbeat.joinable())
        ThreadHeartbeat.join();
}

void ClientManager::connect(const std::string &serverAddress, uint16_t port)
{
    std::cout << std::endl;
    std::cout << "" << std::endl;
    std::cout << "          Starting Tetris Client       " << std::endl;
    std::cout << "" << std::endl;
    std::cout << "   Using NetworkManager version v" << NetworkManager::version << "     " << std::endl;
    std::cout << "   Connection target: " << serverAddress << ":" << port << "  " << std::endl;
    std::cout << "" << std::endl;
    std::cout << std::endl;

    host = enet_host_create(nullptr, 1, 2, 0, 0); // 1 client, 2 channels

    try
    {
        if (!host)
            throw std::runtime_error("Failed to create ENet client host.");
    }
    catch (const std::exception &ex)
    {
        std::cerr << "Error: " << ex.what() << std::endl;
        return;
    }

    ENetAddress address;
    enet_address_set_host(&address, serverAddress.c_str());
    address.port = port;

    serverPeer = enet_host_connect(host, &address, 2, 0);

    try
    {
        if (!serverPeer)
            throw std::runtime_error("No available serverPeers for initiating an ENet connection.");
    }
    catch (const std::exception &ex)
    {
        std::cerr << "Error: " << ex.what() << std::endl;
        return;
    }

    TaskStartHeartbeat();
    TaskStartNetwork();
}

void ClientManager::disconnect()
{
    if (serverPeer)
    {
        enet_peer_disconnect_now(serverPeer, 0);
        enet_peer_reset(serverPeer);
    }
    
    TaskStopNetwork();
    TaskStopHeartbeat();
}

void ClientManager::handleKeyPress(sf::Event keyEvent, sf::RenderWindow &window)
{
    switch (keyEvent.key.code)
    {
    case sf::Keyboard::Escape:
        if (debugEnabled)
            network_print("Tecla ESC pressionada. Fechando a janela.\n");
        window.close();
        break;

    case sf::Keyboard::P:
        if (debugEnabled)
            network_print("Tecla P pressionada. Pausar o jogo.\n");
        send_packet(Packet(PacketType::PAUSE, 0, serverPeer));
        break;

    case sf::Keyboard::R:
        if (debugEnabled)
            network_print("Tecla R pressionada. Reiniciar o jogo.\n");
        send_packet(Packet(PacketType::RESTART, 0, serverPeer));
        break;

    case sf::Keyboard::Q:
        if (debugEnabled)
            network_print("Tecla Q pressionada. Sair do jogo.\n");
        window.close();
        break;

    case sf::Keyboard::Up:
        if (debugEnabled)
            network_print("Tecla Cima (Up) pressionada.\n");
        send_packet(Packet(PacketType::ROTATE_RIGHT, 0, serverPeer));
        break;

    case sf::Keyboard::Down:
        if (debugEnabled)
            network_print("Tecla Baixo (Down) pressionada.\n");
        send_packet(Packet(PacketType::DROP_FASTER, 0, serverPeer));
        break;

    case sf::Keyboard::Left:
        if (debugEnabled)
            network_print("Tecla Esquerda (Left) pressionada.\n");
        send_packet(Packet(PacketType::LEFT, 0, serverPeer));
        break;

    case sf::Keyboard::Right:
        if (debugEnabled)
            network_print("Tecla Direita (Right) pressionada.\n");
        send_packet(Packet(PacketType::RIGHT, 0, serverPeer));
        break;

    case sf::Keyboard::W:
        if (debugEnabled)
            network_print("Tecla W pressionada.\n");
        send_packet(Packet(PacketType::ROTATE_LEFT, 0, serverPeer));
        break;

    case sf::Keyboard::A:
        if (debugEnabled)
            network_print("Tecla A pressionada.\n");
        send_packet(Packet(PacketType::LEFT, 0, serverPeer));
        break;

    case sf::Keyboard::S:
        if (debugEnabled)
            network_print("Tecla S pressionada.\n");
        send_packet(Packet(PacketType::DROP_INSTANT, 0, serverPeer));
        break;

    case sf::Keyboard::D:
        if (debugEnabled)
            network_print("Tecla D pressionada.\n");
        send_packet(Packet(PacketType::RIGHT, 0, serverPeer));
        break;

    case sf::Keyboard::G:
        toggleDebug();
        break;

    default:
        break;
    }
}



// File: ./src/client/TetrisClient.cpp
#include <iostream>
#include "TetrisCell.hpp"

#include "screens/GameScreen.hpp"
#include "screens/MenuScreen.hpp"
#include "screens/LobbyScreen.hpp"
#include "screens/BoardScreen.hpp"
#include "screens/WaitingConnectionScreen.hpp"

#include <enet/enet.h>
#include "ClientManager.hpp"
#include "TetrisActions.hpp"

ClientManager client;

void heartbeat_listener(const Packet &packet)
{
    client.on_receive_heartbeat();
}

// In your registered listener for PLAYER_LIST
void onPlayerListPacket(const Packet &packet)
{
    nlohmann::json received = packet.toJson();
    if (received.contains("action") && received["action"] == "updatePlayerList")
    {
        auto players = received["players"];
        for (auto &p : players)
        {
            int id = p["playerID"];
            std::string name = p["name"];
            std::cout << "Player ID: " << id << ", Name: " << name << "\n";
        }
    }
}

int main()
{
    client.registerListener(PacketType::HEARTBEAT, heartbeat_listener);
    client.registerListener(PacketType::PLAYER_LIST, onPlayerListPacket);

    sf::RenderWindow window(sf::VideoMode(800, 600), "Multi-Threaded Screens");
    ScreenManager screenManager;

    screenManager.addScreen("main-menu", std::make_unique<MenuScreen>(screenManager, client));
    screenManager.addScreen("lobby", std::make_unique<LobbyScreen>());
    screenManager.addScreen("waiting-connection", std::make_unique<WaitingConnectionScreen>(screenManager, client));
    screenManager.addScreen("game", std::make_unique<BoardScreen>());

    screenManager.setActiveScreen("main-menu");
    screenManager.startThread();

    sf::Clock clock;

    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
            {
                window.close();
            }
            screenManager.handleEvent(event);
        }

        float deltaTime = clock.restart().asSeconds();

        window.clear(sf::Color::Black);
        screenManager.render(window);
        window.display();
    }

    while (client.isRunning())
        std::this_thread::sleep_for(std::chrono::milliseconds(10));

    return 0;
}


